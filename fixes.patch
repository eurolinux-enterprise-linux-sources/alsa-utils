From 400e6f440eaa55c634de0242e3a7fbf00a6a50bd Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Fri, 8 Jan 2010 15:58:47 +0100
Subject: [PATCH] aplay: Dump PCM state on xrun when verbose mode is active

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 aplay/aplay.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/aplay/aplay.c b/aplay/aplay.c
index 22a5fe0..e1f7c4d 100644
--- a/aplay/aplay.c
+++ b/aplay/aplay.c
@@ -1176,6 +1176,8 @@ static void xrun(void)
 			fprintf(stderr, _("%s!!! (at least %.3f ms long)\n"),
 				stream == SND_PCM_STREAM_PLAYBACK ? _("underrun") : _("overrun"),
 				diff.tv_sec * 1000 + diff.tv_nsec / 10000000.0);
+			if (verbose)
+				snd_pcm_dump(handle, log);
 #else
 			fprintf(stderr, "%s !!!\n", _("underrun"));
 #endif
-- 
1.7.6

From 0895fcdce2b93bb423b66e9a04d2086528af1c72 Mon Sep 17 00:00:00 2001
From: John Sauter <John_Sauter@systemeyescomputerstore.com>
Date: Fri, 8 Jan 2010 16:21:07 -0500
Subject: [PATCH] aplay - add option --process-id-file

Write the process ID to a file so other programs can
signal aplay.  When aplay exits, delete the file.

Signed-off-by: John Sauter <John_Sauter@systemeyescomputerstore.com>
Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 aplay/aplay.c |  164 +++++++++++++++++++++++++++++++++++----------------------
 1 files changed, 100 insertions(+), 64 deletions(-)

diff --git a/aplay/aplay.c b/aplay/aplay.c
index e1f7c4d..926da64 100644
--- a/aplay/aplay.c
+++ b/aplay/aplay.c
@@ -116,6 +116,10 @@ static int fd = -1;
 static off64_t pbrec_count = LLONG_MAX, fdcount;
 static int vocmajor, vocminor;
 
+static char *pidfile_name = NULL;
+FILE *pidf = NULL;
+static int pidfile_written = 0;
+
 /* needed prototypes */
 
 static void playback(char *filename);
@@ -194,7 +198,8 @@ _("Usage: %s [OPTION]... [FILE]...\n"
 "    --test-position     test ring buffer position\n"
 "    --test-coef=#	 test coeficient for ring buffer position (default 8)\n"
 "                        expression for validation is: coef * (buffer_size / 2)\n"
-"    --test-nowait       do not wait for ring buffer - eats whole CPU\n")
+"    --test-nowait       do not wait for ring buffer - eats whole CPU\n"
+"    --process-id-file   write the process ID here\n")
 		, command);
 	printf(_("Recognized sample formats are:"));
 	for (k = 0; k < SND_PCM_FORMAT_LAST; ++k) {
@@ -324,6 +329,18 @@ static void version(void)
 	printf("%s: version " SND_UTIL_VERSION_STR " by Jaroslav Kysela <perex@perex.cz>\n", command);
 }
 
+/*
+ *	Subroutine to clean up before exit.
+ */
+static void prg_exit(int code) 
+{
+	if (handle)
+		snd_pcm_close(handle);
+	if (pidfile_written)
+		remove (pidfile_name);
+	exit(code);
+}
+
 static void signal_handler(int sig)
 {
 	if (verbose==2)
@@ -345,7 +362,7 @@ static void signal_handler(int sig)
 		snd_pcm_close(handle);
 		handle = NULL;
 	}
-	exit(EXIT_FAILURE);
+	prg_exit(EXIT_FAILURE);
 }
 
 enum {
@@ -358,7 +375,8 @@ enum {
 	OPT_DISABLE_SOFTVOL,
 	OPT_TEST_POSITION,
 	OPT_TEST_COEF,
-	OPT_TEST_NOWAIT
+	OPT_TEST_NOWAIT,
+	OPT_PROCESS_ID_FILE
 };
 
 int main(int argc, char *argv[])
@@ -399,6 +417,7 @@ int main(int argc, char *argv[])
 		{"test-position", 0, 0, OPT_TEST_POSITION},
 		{"test-coef", 1, 0, OPT_TEST_COEF},
 		{"test-nowait", 0, 0, OPT_TEST_NOWAIT},
+		{"process-id-file", 1, 0, OPT_PROCESS_ID_FILE},
 		{0, 0, 0, 0}
 	};
 	char *pcm_name = "default";
@@ -493,7 +512,7 @@ int main(int argc, char *argv[])
 				rhwparams.format = snd_pcm_format_value(optarg);
 				if (rhwparams.format == SND_PCM_FORMAT_UNKNOWN) {
 					error(_("wrong extended format '%s'"), optarg);
-					exit(EXIT_FAILURE);
+					prg_exit(EXIT_FAILURE);
 				}
 			}
 			break;
@@ -588,6 +607,9 @@ int main(int argc, char *argv[])
 		case OPT_TEST_NOWAIT:
 			test_nowait = 1;
 			break;
+		case OPT_PROCESS_ID_FILE:
+			pidfile_name = optarg;
+			break;
 		default:
 			fprintf(stderr, _("Try `%s --help' for more information.\n"), command);
 			return 1;
@@ -643,6 +665,19 @@ int main(int argc, char *argv[])
 		readn_func = snd_pcm_readn;
 	}
 
+	if (pidfile_name) {
+		errno = 0;
+		pidf = fopen (pidfile_name, "w");
+		if (pidf) {
+			(void)fprintf (pidf, "%d\n", getpid());
+			fclose(pidf);
+			pidfile_written = 1;
+		} else {
+			error(_("Cannot create process ID file %s: %s"), 
+				pidfile_name, strerror (errno));
+			return 1;
+		}
+	}
 
 	signal(SIGINT, signal_handler);
 	signal(SIGTERM, signal_handler);
@@ -670,10 +705,13 @@ int main(int argc, char *argv[])
 	if (verbose==2)
 		putchar('\n');
 	snd_pcm_close(handle);
+	handle = NULL;
 	free(audiobuf);
       __end:
 	snd_output_close(log);
 	snd_config_update_free_global();
+	prg_exit(EXIT_SUCCESS);
+	/* avoid warning */
 	return EXIT_SUCCESS;
 }
 
@@ -725,7 +763,7 @@ static size_t test_wavefile_read(int fd, u_char *buffer, size_t *size, size_t re
 		return *size;
 	if ((size_t)safe_read(fd, buffer + *size, reqsize - *size) != reqsize - *size) {
 		error(_("read error (called from line %i)"), line);
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 	return *size = reqsize;
 }
@@ -735,7 +773,7 @@ static size_t test_wavefile_read(int fd, u_char *buffer, size_t *size, size_t re
 		blimit = len; \
 		if ((buffer = realloc(buffer, blimit)) == NULL) { \
 			error(_("not enough memory"));		  \
-			exit(EXIT_FAILURE); \
+			prg_exit(EXIT_FAILURE);  \
 		} \
 	}
 
@@ -784,7 +822,7 @@ static ssize_t test_wavefile(int fd, u_char *_buffer, size_t size)
 	if (len < sizeof(WaveFmtBody)) {
 		error(_("unknown length of 'fmt ' chunk (read %u, should be %u at least)"),
 		      len, (u_int)sizeof(WaveFmtBody));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 	check_wavefile_space(buffer, len, blimit);
 	test_wavefile_read(fd, buffer, &size, len, __LINE__);
@@ -794,22 +832,22 @@ static ssize_t test_wavefile(int fd, u_char *_buffer, size_t size)
 		if (len < sizeof(WaveFmtExtensibleBody)) {
 			error(_("unknown length of extensible 'fmt ' chunk (read %u, should be %u at least)"),
 					len, (u_int)sizeof(WaveFmtExtensibleBody));
-			exit(EXIT_FAILURE);
+			prg_exit(EXIT_FAILURE);
 		}
 		if (memcmp(fe->guid_tag, WAV_GUID_TAG, 14) != 0) {
 			error(_("wrong format tag in extensible 'fmt ' chunk"));
-			exit(EXIT_FAILURE);
+			prg_exit(EXIT_FAILURE);
 		}
 		f->format = fe->guid_format;
 	}
         if (LE_SHORT(f->format) != WAV_FMT_PCM &&
             LE_SHORT(f->format) != WAV_FMT_IEEE_FLOAT) {
                 error(_("can't play WAVE-file format 0x%04x which is not PCM or FLOAT encoded"), LE_SHORT(f->format));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 	if (LE_SHORT(f->channels) < 1) {
 		error(_("can't play WAVE-files with %d tracks"), LE_SHORT(f->channels));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 	hwparams.channels = LE_SHORT(f->channels);
 	switch (LE_SHORT(f->bit_p_spl)) {
@@ -842,7 +880,7 @@ static ssize_t test_wavefile(int fd, u_char *_buffer, size_t size)
 		default:
 			error(_(" can't play WAVE-files with sample %d bits in %d bytes wide (%d channels)"),
 			      LE_SHORT(f->bit_p_spl), LE_SHORT(f->byte_p_spl), hwparams.channels);
-			exit(EXIT_FAILURE);
+			prg_exit(EXIT_FAILURE);
 		}
 		break;
 	case 32:
@@ -854,7 +892,7 @@ static ssize_t test_wavefile(int fd, u_char *_buffer, size_t size)
 	default:
 		error(_(" can't play WAVE-files with sample %d bits wide"),
 		      LE_SHORT(f->bit_p_spl));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 	hwparams.rate = LE_INT(f->sample_fq);
 	
@@ -936,7 +974,7 @@ static int test_au(int fd, void *buffer)
 		return -1;
 	if ((size_t)safe_read(fd, buffer + sizeof(AuHeader), BE_INT(ap->hdr_size) - sizeof(AuHeader)) != BE_INT(ap->hdr_size) - sizeof(AuHeader)) {
 		error(_("read error"));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 	return 0;
 }
@@ -966,7 +1004,7 @@ static void set_params(void)
 	err = snd_pcm_hw_params_any(handle, params);
 	if (err < 0) {
 		error(_("Broken configuration for this PCM: no configurations available"));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 	if (mmap_flag) {
 		snd_pcm_access_mask_t *mask = alloca(snd_pcm_access_mask_sizeof());
@@ -983,18 +1021,18 @@ static void set_params(void)
 						   SND_PCM_ACCESS_RW_NONINTERLEAVED);
 	if (err < 0) {
 		error(_("Access type not available"));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 	err = snd_pcm_hw_params_set_format(handle, params, hwparams.format);
 	if (err < 0) {
 		error(_("Sample format non available"));
 		show_available_sample_formats(params);
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 	err = snd_pcm_hw_params_set_channels(handle, params, hwparams.channels);
 	if (err < 0) {
 		error(_("Channels count non available"));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 
 #if 0
@@ -1052,14 +1090,14 @@ static void set_params(void)
 	if (err < 0) {
 		error(_("Unable to install hw params:"));
 		snd_pcm_hw_params_dump(params, log);
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 	snd_pcm_hw_params_get_period_size(params, &chunk_size, 0);
 	snd_pcm_hw_params_get_buffer_size(params, &buffer_size);
 	if (chunk_size == buffer_size) {
 		error(_("Can't use period equal to buffer size (%lu == %lu)"),
 		      chunk_size, buffer_size);
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 	snd_pcm_sw_params_current(handle, swparams);
 	if (avail_min < 0)
@@ -1090,7 +1128,7 @@ static void set_params(void)
 	if (snd_pcm_sw_params(handle, swparams) < 0) {
 		error(_("unable to install sw params:"));
 		snd_pcm_sw_params_dump(swparams, log);
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 
 	if (verbose)
@@ -1102,7 +1140,7 @@ static void set_params(void)
 	audiobuf = realloc(audiobuf, chunk_bytes);
 	if (audiobuf == NULL) {
 		error(_("not enough memory"));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 	// fprintf(stderr, "real chunk_size = %i, frags = %i, total = %i\n", chunk_size, setup.buf.block.frags, setup.buf.block.frags * chunk_size);
 
@@ -1120,7 +1158,7 @@ static void set_params(void)
 		err = snd_pcm_mmap_begin(handle, &areas, &offset, &size);
 		if (err < 0) {
 			error("snd_pcm_mmap_begin problem: %s", snd_strerror(err));
-			exit(EXIT_FAILURE);
+			prg_exit(EXIT_FAILURE);
 		}
 		for (i = 0; i < hwparams.channels; i++)
 			fprintf(stderr, "mmap_area[%i] = %p,%u,%u (%u)\n", i, areas[i].addr, areas[i].first, areas[i].step, snd_pcm_format_physical_width(hwparams.format));
@@ -1164,7 +1202,7 @@ static void xrun(void)
 	snd_pcm_status_alloca(&status);
 	if ((res = snd_pcm_status(handle, status))<0) {
 		error(_("status error: %s"), snd_strerror(res));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 	if (snd_pcm_status_get_state(status) == SND_PCM_STATE_XRUN) {
 		if (monotonic) {
@@ -1176,8 +1214,6 @@ static void xrun(void)
 			fprintf(stderr, _("%s!!! (at least %.3f ms long)\n"),
 				stream == SND_PCM_STREAM_PLAYBACK ? _("underrun") : _("overrun"),
 				diff.tv_sec * 1000 + diff.tv_nsec / 10000000.0);
-			if (verbose)
-				snd_pcm_dump(handle, log);
 #else
 			fprintf(stderr, "%s !!!\n", _("underrun"));
 #endif
@@ -1196,7 +1232,7 @@ static void xrun(void)
 		}
 		if ((res = snd_pcm_prepare(handle))<0) {
 			error(_("xrun: prepare error: %s"), snd_strerror(res));
-			exit(EXIT_FAILURE);
+			prg_exit(EXIT_FAILURE);
 		}
 		return;		/* ok, data should be accepted again */
 	} if (snd_pcm_status_get_state(status) == SND_PCM_STATE_DRAINING) {
@@ -1208,7 +1244,7 @@ static void xrun(void)
 			fprintf(stderr, _("capture stream format change? attempting recover...\n"));
 			if ((res = snd_pcm_prepare(handle))<0) {
 				error(_("xrun(DRAINING): prepare error: %s"), snd_strerror(res));
-				exit(EXIT_FAILURE);
+				prg_exit(EXIT_FAILURE);
 			}
 			return;
 		}
@@ -1218,7 +1254,7 @@ static void xrun(void)
 		snd_pcm_status_dump(status, log);
 	}
 	error(_("read/write error, state = %s"), snd_pcm_state_name(snd_pcm_status_get_state(status)));
-	exit(EXIT_FAILURE);
+	prg_exit(EXIT_FAILURE);
 }
 
 /* I/O suspend handler */
@@ -1235,7 +1271,7 @@ static void suspend(void)
 			fprintf(stderr, _("Failed. Restarting stream. ")); fflush(stderr);
 		if ((res = snd_pcm_prepare(handle)) < 0) {
 			error(_("suspend: prepare error: %s"), snd_strerror(res));
-			exit(EXIT_FAILURE);
+			prg_exit(EXIT_FAILURE);
 		}
 	}
 	if (!quiet_mode)
@@ -1540,7 +1576,7 @@ static ssize_t pcm_write(u_char *data, size_t count)
 			suspend();
 		} else if (r < 0) {
 			error(_("write error: %s"), snd_strerror(r));
-			exit(EXIT_FAILURE);
+			prg_exit(EXIT_FAILURE);
 		}
 		if (r > 0) {
 			if (vumeter)
@@ -1586,7 +1622,7 @@ static ssize_t pcm_writev(u_char **data, unsigned int channels, size_t count)
 			suspend();
 		} else if (r < 0) {
 			error(_("writev error: %s"), snd_strerror(r));
-			exit(EXIT_FAILURE);
+			prg_exit(EXIT_FAILURE);
 		}
 		if (r > 0) {
 			if (vumeter) {
@@ -1629,7 +1665,7 @@ static ssize_t pcm_read(u_char *data, size_t rcount)
 			suspend();
 		} else if (r < 0) {
 			error(_("read error: %s"), snd_strerror(r));
-			exit(EXIT_FAILURE);
+			prg_exit(EXIT_FAILURE);
 		}
 		if (r > 0) {
 			if (vumeter)
@@ -1672,7 +1708,7 @@ static ssize_t pcm_readv(u_char **data, unsigned int channels, size_t rcount)
 			suspend();
 		} else if (r < 0) {
 			error(_("readv error: %s"), snd_strerror(r));
-			exit(EXIT_FAILURE);
+			prg_exit(EXIT_FAILURE);
 		}
 		if (r > 0) {
 			if (vumeter) {
@@ -1729,7 +1765,7 @@ static void voc_write_silence(unsigned x)
 			l = chunk_size;
 		if (voc_pcm_write(buf, l) != (ssize_t)l) {
 			error(_("write error"));
-			exit(EXIT_FAILURE);
+			prg_exit(EXIT_FAILURE);
 		}
 		x -= l;
 	}
@@ -1771,7 +1807,7 @@ static void voc_play(int fd, int ofs, char *name)
 	buffer_pos = 0;
 	if (data == NULL) {
 		error(_("malloc error"));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 	if (!quiet_mode) {
 		fprintf(stderr, _("Playing Creative Labs Channel file '%s'...\n"), name);
@@ -1780,14 +1816,14 @@ static void voc_play(int fd, int ofs, char *name)
 	while (ofs > (ssize_t)chunk_bytes) {
 		if ((size_t)safe_read(fd, buf, chunk_bytes) != chunk_bytes) {
 			error(_("read error"));
-			exit(EXIT_FAILURE);
+			prg_exit(EXIT_FAILURE);
 		}
 		ofs -= chunk_bytes;
 	}
 	if (ofs) {
 		if (safe_read(fd, buf, ofs) != ofs) {
 			error(_("read error"));
-			exit(EXIT_FAILURE);
+			prg_exit(EXIT_FAILURE);
 		}
 	}
 	hwparams.format = DEFAULT_FORMAT;
@@ -1811,7 +1847,7 @@ static void voc_play(int fd, int ofs, char *name)
 				nextblock = buf[0] = 0;
 				if (l == -1) {
 					perror(name);
-					exit(EXIT_FAILURE);
+					prg_exit(EXIT_FAILURE);
 				}
 			}
 		}
@@ -1955,12 +1991,12 @@ static void voc_play(int fd, int ofs, char *name)
 			if (output && !quiet_mode) {
 				if (write(2, data, l) != l) {	/* to stderr */
 					error(_("write error"));
-					exit(EXIT_FAILURE);
+					prg_exit(EXIT_FAILURE);
 				}
 			} else {
 				if (voc_pcm_write(data, l) != l) {
 					error(_("write error"));
-					exit(EXIT_FAILURE);
+					prg_exit(EXIT_FAILURE);
 				}
 			}
 			COUNT(l);
@@ -2007,7 +2043,7 @@ static void begin_voc(int fd, size_t cnt)
 
 	if (write(fd, &vh, sizeof(VocHeader)) != sizeof(VocHeader)) {
 		error(_("write error"));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 	if (hwparams.channels > 1) {
 		/* write an extended block */
@@ -2016,14 +2052,14 @@ static void begin_voc(int fd, size_t cnt)
 		bt.datalen_m = bt.datalen_h = 0;
 		if (write(fd, &bt, sizeof(VocBlockType)) != sizeof(VocBlockType)) {
 			error(_("write error"));
-			exit(EXIT_FAILURE);
+			prg_exit(EXIT_FAILURE);
 		}
 		eb.tc = LE_SHORT(65536 - 256000000L / (hwparams.rate << 1));
 		eb.pack = 0;
 		eb.mode = 1;
 		if (write(fd, &eb, sizeof(VocExtBlock)) != sizeof(VocExtBlock)) {
 			error(_("write error"));
-			exit(EXIT_FAILURE);
+			prg_exit(EXIT_FAILURE);
 		}
 	}
 	bt.type = 1;
@@ -2033,13 +2069,13 @@ static void begin_voc(int fd, size_t cnt)
 	bt.datalen_h = (u_char) ((cnt & 0xFF0000) >> 16);
 	if (write(fd, &bt, sizeof(VocBlockType)) != sizeof(VocBlockType)) {
 		error(_("write error"));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 	vd.tc = (u_char) (256 - (1000000 / hwparams.rate));
 	vd.pack = 0;
 	if (write(fd, &vd, sizeof(VocVoiceData)) != sizeof(VocVoiceData)) {
 		error(_("write error"));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 }
 
@@ -2075,7 +2111,7 @@ static void begin_wave(int fd, size_t cnt)
 		break;
 	default:
 		error(_("Wave doesn't support %s format..."), snd_pcm_format_name(hwparams.format));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 	h.magic = WAV_RIFF;
 	tmp = cnt + sizeof(WaveHeader) + sizeof(WaveChunkHeader) + sizeof(WaveFmtBody) + sizeof(WaveChunkHeader) - 8;
@@ -2111,7 +2147,7 @@ static void begin_wave(int fd, size_t cnt)
 	    write(fd, &f, sizeof(WaveFmtBody)) != sizeof(WaveFmtBody) ||
 	    write(fd, &cd, sizeof(WaveChunkHeader)) != sizeof(WaveChunkHeader)) {
 		error(_("write error"));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 }
 
@@ -2135,13 +2171,13 @@ static void begin_au(int fd, size_t cnt)
 		break;
 	default:
 		error(_("Sparc Audio doesn't support %s format..."), snd_pcm_format_name(hwparams.format));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 	ah.sample_rate = BE_INT(hwparams.rate);
 	ah.channels = BE_INT(hwparams.channels);
 	if (write(fd, &ah, sizeof(AuHeader)) != sizeof(AuHeader)) {
 		error(_("write error"));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 }
 
@@ -2155,7 +2191,7 @@ static void end_voc(int fd)
 
 	if (write(fd, &dummy, 1) != 1) {
 		error(_("write error"));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 	length_seek = sizeof(VocHeader);
 	if (hwparams.channels > 1)
@@ -2263,7 +2299,7 @@ static void playback_go(int fd, size_t loaded, off64_t count, int rtype, char *n
 			r = safe_read(fd, audiobuf + l, c);
 			if (r < 0) {
 				perror(name);
-				exit(EXIT_FAILURE);
+				prg_exit(EXIT_FAILURE);
 			}
 			fdcount += r;
 			if (r == 0)
@@ -2302,14 +2338,14 @@ static void playback(char *name)
 	} else {
 		if ((fd = open64(name, O_RDONLY, 0)) == -1) {
 			perror(name);
-			exit(EXIT_FAILURE);
+			prg_exit(EXIT_FAILURE);
 		}
 	}
 	/* read the file header */
 	dta = sizeof(AuHeader);
 	if ((size_t)safe_read(fd, audiobuf, dta) != dta) {
 		error(_("read error"));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 	if (test_au(fd, audiobuf) >= 0) {
 		rhwparams.format = hwparams.format;
@@ -2321,7 +2357,7 @@ static void playback(char *name)
 	if ((size_t)safe_read(fd, audiobuf + sizeof(AuHeader),
 		 dta - sizeof(AuHeader)) != dta - sizeof(AuHeader)) {
 		error(_("read error"));
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);;
 	}
 	if ((ofs = test_vocfile(audiobuf)) >= 0) {
 		pbrec_count = calc_count();
@@ -2430,7 +2466,7 @@ static void capture(char *orig_name)
 			remove(name);
 			if ((fd = open64(name, O_WRONLY | O_CREAT, 0644)) == -1) {
 				perror(name);
-				exit(EXIT_FAILURE);
+				prg_exit(EXIT_FAILURE);
 			}
 			filecount++;
 		}
@@ -2453,7 +2489,7 @@ static void capture(char *orig_name)
 				break;
 			if (write(fd, audiobuf, c) != c) {
 				perror(name);
-				exit(EXIT_FAILURE);
+				prg_exit(EXIT_FAILURE);
 			}
 			count -= c;
 			rest -= c;
@@ -2500,12 +2536,12 @@ static void playbackv_go(int* fds, unsigned int channels, size_t loaded, off64_t
 			r = safe_read(fds[0], bufs[0], expected);
 			if (r < 0) {
 				perror(names[channel]);
-				exit(EXIT_FAILURE);
+				prg_exit(EXIT_FAILURE);
 			}
 			for (channel = 1; channel < channels; ++channel) {
 				if (safe_read(fds[channel], bufs[channel], r) != r) {
 					perror(names[channel]);
-					exit(EXIT_FAILURE);
+					prg_exit(EXIT_FAILURE);
 				}
 			}
 			if (r == 0)
@@ -2552,7 +2588,7 @@ static void capturev_go(int* fds, unsigned int channels, off64_t count, int rtyp
 		for (channel = 0; channel < channels; ++channel) {
 			if ((size_t)write(fds[channel], bufs[channel], rv) != rv) {
 				perror(names[channel]);
-				exit(EXIT_FAILURE);
+				prg_exit(EXIT_FAILURE);
 			}
 		}
 		r = r * bits_per_frame / 8;
@@ -2585,7 +2621,7 @@ static void playbackv(char **names, unsigned int count)
 		alloced = 1;
 	} else if (count != channels) {
 		error(_("You need to specify %d files"), channels);
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 
 	for (channel = 0; channel < channels; ++channel) {
@@ -2611,7 +2647,7 @@ static void playbackv(char **names, unsigned int count)
 	if (alloced)
 		free(names);
 	if (ret)
-		exit(ret);
+		prg_exit(ret);
 }
 
 static void capturev(char **names, unsigned int count)
@@ -2638,7 +2674,7 @@ static void capturev(char **names, unsigned int count)
 		alloced = 1;
 	} else if (count != channels) {
 		error(_("You need to specify %d files"), channels);
-		exit(EXIT_FAILURE);
+		prg_exit(EXIT_FAILURE);
 	}
 
 	for (channel = 0; channel < channels; ++channel) {
@@ -2664,5 +2700,5 @@ static void capturev(char **names, unsigned int count)
 	if (alloced)
 		free(names);
 	if (ret)
-		exit(ret);
+		prg_exit(ret);
 }
-- 
1.7.6

From 3b425f8fb5b33fedd09f725d044cb5cbe3adda37 Mon Sep 17 00:00:00 2001
From: John Sauter <John_Sauter@systemeyescomputerstore.com>
Date: Fri, 8 Jan 2010 16:24:33 -0500
Subject: [PATCH] aplay -- add features for audio surveilance

Add signal SIGUSR1 to turn over the output file,
--max-file-time to cause the output file to turn over automatically,
and --use-strftime to create output files based on the current time.

Signed-off-by: John Sauter <John_Sauter@systemeyescomputerstore.com>
Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 aplay/aplay.c |  187 +++++++++++++++++++++++++++++++++++++++++++++++++++++++--
 1 files changed, 181 insertions(+), 6 deletions(-)

diff --git a/aplay/aplay.c b/aplay/aplay.c
index 926da64..e1d8e6a 100644
--- a/aplay/aplay.c
+++ b/aplay/aplay.c
@@ -111,6 +111,10 @@ static int test_position = 0;
 static int test_coef = 8;
 static int test_nowait = 0;
 static snd_output_t *log;
+static long long max_file_size = 0;
+static int max_file_time = 0;
+static int use_strftime = 0;
+volatile static int recycle_capture_file = 0;
 
 static int fd = -1;
 static off64_t pbrec_count = LLONG_MAX, fdcount;
@@ -199,7 +203,10 @@ _("Usage: %s [OPTION]... [FILE]...\n"
 "    --test-coef=#	 test coeficient for ring buffer position (default 8)\n"
 "                        expression for validation is: coef * (buffer_size / 2)\n"
 "    --test-nowait       do not wait for ring buffer - eats whole CPU\n"
-"    --process-id-file   write the process ID here\n")
+"    --max-file-time=#   start another output file when the old file has recorded\n"
+"                        for this many seconds\n"
+"    --process-id-file   write the process ID here\n"
+"    --use-strftime      apply the strftime facility to the output file name\n")
 		, command);
 	printf(_("Recognized sample formats are:"));
 	for (k = 0; k < SND_PCM_FORMAT_LAST; ++k) {
@@ -365,6 +372,13 @@ static void signal_handler(int sig)
 	prg_exit(EXIT_FAILURE);
 }
 
+/* call on SIGUSR1 signal. */
+static void signal_handler_recycle (int sig)
+{
+	/* flag the capture loop to start a new output file */
+	recycle_capture_file = 1;
+}
+
 enum {
 	OPT_VERSION = 1,
 	OPT_PERIOD_SIZE,
@@ -376,7 +390,9 @@ enum {
 	OPT_TEST_POSITION,
 	OPT_TEST_COEF,
 	OPT_TEST_NOWAIT,
-	OPT_PROCESS_ID_FILE
+	OPT_MAX_FILE_TIME,
+	OPT_PROCESS_ID_FILE,
+	OPT_USE_STRFTIME
 };
 
 int main(int argc, char *argv[])
@@ -417,7 +433,9 @@ int main(int argc, char *argv[])
 		{"test-position", 0, 0, OPT_TEST_POSITION},
 		{"test-coef", 1, 0, OPT_TEST_COEF},
 		{"test-nowait", 0, 0, OPT_TEST_NOWAIT},
+		{"max-file-time", 1, 0, OPT_MAX_FILE_TIME},
 		{"process-id-file", 1, 0, OPT_PROCESS_ID_FILE},
+		{"use-strftime", 0, 0, OPT_USE_STRFTIME},
 		{0, 0, 0, 0}
 	};
 	char *pcm_name = "default";
@@ -607,9 +625,15 @@ int main(int argc, char *argv[])
 		case OPT_TEST_NOWAIT:
 			test_nowait = 1;
 			break;
+		case OPT_MAX_FILE_TIME:
+			max_file_time = strtol(optarg, NULL, 0);
+			break;
 		case OPT_PROCESS_ID_FILE:
 			pidfile_name = optarg;
 			break;
+		case OPT_USE_STRFTIME:
+			use_strftime = 1;
+			break;
 		default:
 			fprintf(stderr, _("Try `%s --help' for more information.\n"), command);
 			return 1;
@@ -682,6 +706,7 @@ int main(int argc, char *argv[])
 	signal(SIGINT, signal_handler);
 	signal(SIGTERM, signal_handler);
 	signal(SIGABRT, signal_handler);
+	signal(SIGUSR1, signal_handler_recycle);
 	if (interleaved) {
 		if (optind > argc - 1) {
 			if (stream == SND_PCM_STREAM_PLAYBACK)
@@ -2379,13 +2404,98 @@ static void playback(char *name)
 		close(fd);
 }
 
+/**
+ * mystrftime
+ *
+ *   Variant of strftime(3) that supports additional format
+ *   specifiers in the format string.
+ *
+ * Parameters:
+ *
+ *   s	  - destination string
+ *   max	- max number of bytes to write
+ *   userformat - format string
+ *   tm	 - time information
+ *   filenumber - the number of the file, starting at 1
+ *
+ * Returns: number of bytes written to the string s
+ */
+size_t mystrftime(char *s, size_t max, const char *userformat,
+		  const struct tm *tm, const int filenumber)
+{
+	char formatstring[PATH_MAX] = "";
+	char tempstring[PATH_MAX] = "";
+	char *format, *tempstr;
+	const char *pos_userformat;
+
+	format = formatstring;
+
+	/* if mystrftime is called with userformat = NULL we return a zero length string */
+	if (userformat == NULL) {
+		*s = '\0';
+		return 0;
+	}
+
+	for (pos_userformat = userformat; *pos_userformat; ++pos_userformat) {
+		if (*pos_userformat == '%') {
+			tempstr = tempstring;
+			tempstr[0] = '\0';
+			switch (*++pos_userformat) {
+
+				case '\0': // end of string
+					--pos_userformat;
+					break;
+
+				case 'v': // file number 
+					sprintf(tempstr, "%02d", filenumber);
+					break;
+
+				default: // All other codes will be handled by strftime
+					*format++ = '%';
+					*format++ = *pos_userformat;
+					continue;
+			}
+
+			/* If a format specifier was found and used, copy the result. */
+			if (tempstr[0]) {
+				while ((*format = *tempstr++) != '\0')
+					++format;
+				continue;
+			}
+		}
+
+		/* For any other character than % we simply copy the character */
+		*format++ = *pos_userformat;
+	}
+
+	*format = '\0';
+	format = formatstring;
+	return strftime(s, max, format, tm);
+}
+
 static int new_capture_file(char *name, char *namebuf, size_t namelen,
 			    int filecount)
 {
-	/* get a copy of the original filename */
 	char *s;
 	char buf[PATH_MAX+1];
+	time_t t;
+	struct tm *tmp;
+
+	if (use_strftime) {
+		t = time(NULL);
+		tmp = localtime(&t);
+		if (tmp == NULL) {
+			perror("localtime");
+			prg_exit(EXIT_FAILURE);
+		}
+		if (mystrftime(namebuf, namelen, name, tmp, filecount+1) == 0) {
+			fprintf(stderr, "mystrftime returned 0");
+			prg_exit(EXIT_FAILURE);
+		}
+		return filecount;
+	}
 
+	/* get a copy of the original filename */
 	strncpy(buf, name, sizeof(buf));
 
 	/* separate extension from filename */
@@ -2417,6 +2527,58 @@ static int new_capture_file(char *name, char *namebuf, size_t namelen,
 	return filecount;
 }
 
+/**
+ * create_path
+ *
+ *   This function creates a file path, like mkdir -p. 
+ *
+ * Parameters:
+ *
+ *   path - the path to create
+ *
+ * Returns: 0 on success, -1 on failure
+ * On failure, a message has been printed to stderr.
+ */
+int create_path(const char *path)
+{
+	char *start;
+	mode_t mode = S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH;
+
+	if (path[0] == '/')
+		start = strchr(path + 1, '/');
+	else
+		start = strchr(path, '/');
+
+	while (start) {
+		char *buffer = strdup(path);
+		buffer[start-path] = 0x00;
+
+		if (mkdir(buffer, mode) == -1 && errno != EEXIST) {
+			fprintf(stderr, "Problem creating directory %s", buffer);
+			perror(" ");
+			free(buffer);
+			return -1;
+		}
+		free(buffer);
+		start = strchr(start + 1, '/');
+	}
+	return 0;
+}
+
+static int safe_open(const char *name)
+{
+	int fd;
+
+	fd = open64(name, O_WRONLY | O_CREAT, 0644);
+	if (fd == -1) {
+		if (errno != ENOENT || !use_strftime)
+			return -1;
+		if (create_path(name) == 0)
+			fd = open64(name, O_WRONLY | O_CREAT, 0644);
+	}
+	return fd;
+}
+
 static void capture(char *orig_name)
 {
 	int tostdout=0;		/* boolean which describes output stream */
@@ -2429,6 +2591,10 @@ static void capture(char *orig_name)
 	count = calc_count();
 	if (count == 0)
 		count = LLONG_MAX;
+	/* compute the number of bytes per file */
+	max_file_size = max_file_time *
+		snd_pcm_format_size(hwparams.format,
+				    hwparams.rate * hwparams.channels);
 	/* WAVE-file should be even (I'm not sure), but wasting one byte
 	   isn't a problem (this can only be in 8 bit mono) */
 	if (count < LLONG_MAX)
@@ -2455,7 +2621,7 @@ static void capture(char *orig_name)
 		/* open a file to write */
 		if(!tostdout) {
 			/* upon the second file we start the numbering scheme */
-			if (filecount) {
+			if (filecount || use_strftime) {
 				filecount = new_capture_file(orig_name, namebuf,
 							     sizeof(namebuf),
 							     filecount);
@@ -2464,7 +2630,8 @@ static void capture(char *orig_name)
 			
 			/* open a new file */
 			remove(name);
-			if ((fd = open64(name, O_WRONLY | O_CREAT, 0644)) == -1) {
+			fd = safe_open(name);
+			if (fd < 0) {
 				perror(name);
 				prg_exit(EXIT_FAILURE);
 			}
@@ -2474,6 +2641,8 @@ static void capture(char *orig_name)
 		rest = count;
 		if (rest > fmt_rec_table[file_type].max_filesize)
 			rest = fmt_rec_table[file_type].max_filesize;
+		if (max_file_size && (rest > max_file_size)) 
+			rest = max_file_size;
 
 		/* setup sample header */
 		if (fmt_rec_table[file_type].start)
@@ -2481,7 +2650,7 @@ static void capture(char *orig_name)
 
 		/* capture */
 		fdcount = 0;
-		while (rest > 0) {
+		while (rest > 0 && recycle_capture_file == 0) {
 			size_t c = (rest <= (off64_t)chunk_bytes) ?
 				(size_t)rest : chunk_bytes;
 			size_t f = c * 8 / bits_per_frame;
@@ -2496,6 +2665,12 @@ static void capture(char *orig_name)
 			fdcount += c;
 		}
 
+		/* re-enable SIGUSR1 signal */
+		if (recycle_capture_file) {
+			recycle_capture_file = 0;
+			signal(SIGUSR1, signal_handler_recycle);
+		}
+
 		/* finish sample container */
 		if (fmt_rec_table[file_type].end && !tostdout) {
 			fmt_rec_table[file_type].end(fd);
-- 
1.7.6

From 55cd025f18e3d954d700fa30b35e5318b4288e74 Mon Sep 17 00:00:00 2001
From: John Sauter <John_Sauter@systemeyescomputerstore.com>
Date: Fri, 8 Jan 2010 16:28:57 -0500
Subject: [PATCH] aplay -- update the man file

Bring the man file up to date, documenting the signals and all the
options, including those added for audio surveilance.

Signed-off-by: John Sauter <John_Sauter@systemeyescomputerstore.com>
Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 aplay/aplay.1 |   91 ++++++++++++++++++++++++++++++++++++++++++++++++++++----
 1 files changed, 84 insertions(+), 7 deletions(-)

diff --git a/aplay/aplay.1 b/aplay/aplay.1
index 7759347..b6caf0b 100644
--- a/aplay/aplay.1
+++ b/aplay/aplay.1
@@ -1,4 +1,4 @@
-.TH APLAY 1 "2 August 2001"
+.TH APLAY 1 "1 January 2010"
 .SH NAME
 arecord, aplay \- command-line sound recorder and player for ALSA 
 soundcard driver
@@ -46,6 +46,7 @@ If this parameter is omitted the WAVE format is used.
 \fI\-c, \-\-channels=#\fP
 The number of channels.
 The default is one channel.
+Valid values are 1 through 32.
 .TP
 \fI\-f \-\-format=FORMAT\fP
 Sample format
@@ -53,19 +54,23 @@ Sample format
 Recognized sample formats are: S8 U8 S16_LE S16_BE U16_LE U16_BE S24_LE
 S24_BE U24_LE U24_BE S32_LE S32_BE U32_LE U32_BE FLOAT_LE FLOAT_BE
 FLOAT64_LE FLOAT64_BE IEC958_SUBFRAME_LE IEC958_SUBFRAME_BE MU_LAW
-A_LAW IMA_ADPCM MPEG GSM
+A_LAW IMA_ADPCM MPEG GSM SPECIAL S24_3LE S24_3BE U24_3LE U24_3BE S20_3LE
+S20_3BE U20_3LE U20_3BE S18_3LE S18_3BE U18_3LE
 .br
 Some of these may not be available on selected hardware
 .br
-There are also two format shortcuts available:
+The available format shortcuts are:
 .nf
-\-f cd (16 bit little endian, 44100, stereo [\-f S16_LE \-c2 \-r44100]
+\-f cd (16 bit little endian, 44100, stereo) [\-f S16_LE \-c2 \-r44100]
+\-f cdr (16 bit big endian, 44100, stereo) [\-f S16_BE \-c2 \-f44100]
 \-f dat (16 bit little endian, 48000, stereo) [\-f S16_LE \-c2 \-r48000]
 .fi
 If no format is given U8 is used.
 .TP
 \fI\-r, \-\-rate=#<Hz>\fP
 Sampling rate in Hertz. The default rate is 8000 Hertz.
+If the value specified is less than 300, it is taken as the rate in kilohertz.
+Valid values are 2000 through 192000 Hertz.
 .TP
 \fI\-d, \-\-duration=#\fP
 Interrupt after # seconds.
@@ -120,10 +125,69 @@ The stereo VU-meter is available only for 2-channel stereo samples
 with interleaved format.
 .TP
 \fI\-I, \-\-separate\-channels\fP 
-One file for each channel
+One file for each channel.  This option disables max\-file\-time
+and use\-strftime, and ignores SIGUSR1.  The stereo VU meter is
+not available with separate channels.
+.TP
+\fI\-P\fP
+Playback.  This is the default if the program is invoked
+by typing aplay.
+.TP
+\fI\-C\fP
+Record.  This is the default if the program is invoked
+by typing arecord.
+.TP
+\fI\-\-disable\-resample\fP
+Disable automatic rate resample.
+.TP
+\fI\-\-disable\-channels\fP
+Disable automatic channel conversions.
+.TP
+\fI\-\-disable\-format\fP
+Disable automatic format conversions.
+.TP
+\fI\-\-disable\-softvol\fP
+Disable software volume control (softvol).
+.TP
+\fI\-\-test\-position\fP
+Test ring buffer position.
+.TP
+\fI\-\-test\-coef=<coef>\fP
+Test coefficient for ring buffer position; default is 8.
+Expression for validation is: coef * (buffer_size / 2).
+Minimum value is 1.
+.TP
+\fI\-\-test\-nowait\fP
+Do not wait for the ring buffer--eats the whole CPU.
+.TP
+\fI\-\-max\-file\-time\fP
+While recording, when the output file has been accumulating
+sound for this long,
+close it and open a new output file.  Default is the maximum
+size supported by the file format: 2 GiB for WAV files.
+This option has no effect if  \-\-separate\-channels is
+specified.
+.TP
+\fI\-\-process\-id\-file <file name>\fP
+aplay writes its process ID here, so other programs can
+send signals to it.
+.TP
+\fI\-\-use\-strftime\fP
+When recording, interpret %-codes in the file name parameter using
+the strftime facility whenever the output file is opened.  The
+important strftime codes are: %Y is the year, %m month, %d day of
+the month, %H hour, %M minute and %S second.  In addition, %v is
+the file number, starting at 1.  When this option is specified,
+intermediate directories for the output file are created automatically.
+This option has no effect if \-\-separate\-channels is specified.
 
-.SS
-Example:
+.SH SIGNALS
+When recording, SIGINT, SIGTERM and SIGABRT will close the output 
+file and exit.  SIGUSR1 will close the output file, open a new one,
+and continue recording.  However, SIGUSR1 does not work with
+\-\-separate\-channels.
+
+.SH EXAMPLES
 
 .TP
 \fBaplay \-c 1 \-t raw \-r 22050 \-f mu_law foobar\fR
@@ -144,6 +208,19 @@ pcm.copy {
 }
 .fi
 
+.TP
+\fBarecord \-t wav \-max-file_time 30 mon.wav\fP
+Record from the default audio source in monaural, 8,000 samples
+per second, 8 bits per sample.  Start a new file every
+30 seconds.  File names are mon-nn.wav, where nn increases
+from 01.  The file after mon-99.wav is mon-100.wav.
+
+.TP
+\fBarecord \-f cd \-t wav \-max-file-time 3600 --use-strftime %Y/%m/%d/listen-%H-%M-%v.wav\fP
+Record in stereo from the default audio source.  Create a new file
+every hour.  The files are placed in directories based on their start dates
+and have names which include their start times and file numbers.
+
 .SH SEE ALSO
 \fB
 alsamixer(1),
-- 
1.7.6

From c2eaf88f7e070770dae442a2000e3926750dbb54 Mon Sep 17 00:00:00 2001
From: Clemens Ladisch <clemens@ladisch.de>
Date: Mon, 25 Jan 2010 14:11:37 +0100
Subject: [PATCH] amidi: fix port listing

Rewrite the port listing code because it was too complex and had some
bugs when handling write-only or read-only ports.

Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
---
 amidi/amidi.c |  131 ++++++++++++++++-----------------------------------------
 1 files changed, 36 insertions(+), 95 deletions(-)

diff --git a/amidi/amidi.c b/amidi/amidi.c
index 2e970ae..cedf18c 100644
--- a/amidi/amidi.c
+++ b/amidi/amidi.c
@@ -95,122 +95,63 @@ static void *my_malloc(size_t size)
 	return p;
 }
 
-static int is_input(snd_ctl_t *ctl, int card, int device, int sub)
-{
-	snd_rawmidi_info_t *info;
-	int err;
-
-	snd_rawmidi_info_alloca(&info);
-	snd_rawmidi_info_set_device(info, device);
-	snd_rawmidi_info_set_subdevice(info, sub);
-	snd_rawmidi_info_set_stream(info, SND_RAWMIDI_STREAM_INPUT);
-	
-	if ((err = snd_ctl_rawmidi_info(ctl, info)) < 0 && err != -ENXIO)
-		return err;
-	else if (err == 0)
-		return 1;
-
-	return 0;
-}
-
-static int is_output(snd_ctl_t *ctl, int card, int device, int sub)
-{
-	snd_rawmidi_info_t *info;
-	int err;
-
-	snd_rawmidi_info_alloca(&info);
-	snd_rawmidi_info_set_device(info, device);
-	snd_rawmidi_info_set_subdevice(info, sub);
-	snd_rawmidi_info_set_stream(info, SND_RAWMIDI_STREAM_OUTPUT);
-	
-	if ((err = snd_ctl_rawmidi_info(ctl, info)) < 0 && err != -ENXIO)
-		return err;
-	else if (err == 0)
-		return 1;
-
-	return 0;
-}
-
 static void list_device(snd_ctl_t *ctl, int card, int device)
 {
 	snd_rawmidi_info_t *info;
 	const char *name;
 	const char *sub_name;
 	int subs, subs_in, subs_out;
-	int sub, in, out;
+	int sub;
 	int err;
 
 	snd_rawmidi_info_alloca(&info);
 	snd_rawmidi_info_set_device(info, device);
 
 	snd_rawmidi_info_set_stream(info, SND_RAWMIDI_STREAM_INPUT);
-	snd_ctl_rawmidi_info(ctl, info);
-	subs_in = snd_rawmidi_info_get_subdevices_count(info);
+	err = snd_ctl_rawmidi_info(ctl, info);
+	if (err >= 0)
+		subs_in = snd_rawmidi_info_get_subdevices_count(info);
+	else
+		subs_in = 0;
+
 	snd_rawmidi_info_set_stream(info, SND_RAWMIDI_STREAM_OUTPUT);
-	snd_ctl_rawmidi_info(ctl, info);
-	subs_out = snd_rawmidi_info_get_subdevices_count(info);
-	subs = subs_in > subs_out ? subs_in : subs_out;
+	err = snd_ctl_rawmidi_info(ctl, info);
+	if (err >= 0)
+		subs_out = snd_rawmidi_info_get_subdevices_count(info);
+	else
+		subs_out = 0;
 
-	sub = 0;
-	in = out = 0;
-	if ((err = is_output(ctl, card, device, sub)) < 0) {
-		error("cannot get rawmidi information %d:%d: %s",
-		      card, device, snd_strerror(err));
+	subs = subs_in > subs_out ? subs_in : subs_out;
+	if (!subs)
 		return;
-	} else if (err)
-		out = 1;
 
-	if (err == 0) {
-		if ((err = is_input(ctl, card, device, sub)) < 0) {
-			error("cannot get rawmidi information %d:%d: %s",
-			      card, device, snd_strerror(err));
+	for (sub = 0; sub < subs; ++sub) {
+		snd_rawmidi_info_set_stream(info, sub < subs_in ?
+					    SND_RAWMIDI_STREAM_INPUT :
+					    SND_RAWMIDI_STREAM_OUTPUT);
+		snd_rawmidi_info_set_subdevice(info, sub);
+		err = snd_ctl_rawmidi_info(ctl, info);
+		if (err < 0) {
+			error("cannot get rawmidi information %d:%d:%d: %s\n",
+			      card, device, sub, snd_strerror(err));
 			return;
 		}
-	} else if (err) 
-		in = 1;
-
-	if (err == 0)
-		return;
-
-	name = snd_rawmidi_info_get_name(info);
-	sub_name = snd_rawmidi_info_get_subdevice_name(info);
-	if (sub_name[0] == '\0') {
-		if (subs == 1) {
-			printf("%c%c  hw:%d,%d    %s\n", 
-			       in ? 'I' : ' ', out ? 'O' : ' ',
+		name = snd_rawmidi_info_get_name(info);
+		sub_name = snd_rawmidi_info_get_subdevice_name(info);
+		if (sub == 0 && sub_name[0] == '\0') {
+			printf("%c%c  hw:%d,%d    %s",
+			       sub < subs_in ? 'I' : ' ',
+			       sub < subs_out ? 'O' : ' ',
 			       card, device, name);
-		} else
-			printf("%c%c  hw:%d,%d    %s (%d subdevices)\n",
-			       in ? 'I' : ' ', out ? 'O' : ' ',
-			       card, device, name, subs);
-	} else {
-		sub = 0;
-		for (;;) {
+			if (subs > 1)
+				printf(" (%d subdevices)", subs);
+			putchar('\n');
+			break;
+		} else {
 			printf("%c%c  hw:%d,%d,%d  %s\n",
-			       in ? 'I' : ' ', out ? 'O' : ' ',
+			       sub < subs_in ? 'I' : ' ',
+			       sub < subs_out ? 'O' : ' ',
 			       card, device, sub, sub_name);
-			if (++sub >= subs)
-				break;
-
-			in = is_input(ctl, card, device, sub);
-			out = is_output(ctl, card, device, sub);
-			snd_rawmidi_info_set_subdevice(info, sub);
-			if (out) {
-				snd_rawmidi_info_set_stream(info, SND_RAWMIDI_STREAM_OUTPUT);
-				if ((err = snd_ctl_rawmidi_info(ctl, info)) < 0) {
-					error("cannot get rawmidi information %d:%d:%d: %s",
-					      card, device, sub, snd_strerror(err));
-					break;
-				} 
-			} else {
-				snd_rawmidi_info_set_stream(info, SND_RAWMIDI_STREAM_INPUT);
-				if ((err = snd_ctl_rawmidi_info(ctl, info)) < 0) {
-					error("cannot get rawmidi information %d:%d:%d: %s",
-					      card, device, sub, snd_strerror(err));
-					break;
-				}
-			}
-			sub_name = snd_rawmidi_info_get_subdevice_name(info);
 		}
 	}
 }
-- 
1.7.6

From 0034b1f83f6e14f89a2fc2b2b02f14fcf0e93b2f Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Wed, 27 Jan 2010 10:26:52 +0100
Subject: [PATCH] speaker-test: add fflush(stdout) to write_loop

Flush stdout for pipes. The monitor tool from hda-analyzer requires this.

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 speaker-test/speaker-test.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/speaker-test/speaker-test.c b/speaker-test/speaker-test.c
index 053ed3b..d8d68e2 100644
--- a/speaker-test/speaker-test.c
+++ b/speaker-test/speaker-test.c
@@ -689,6 +689,7 @@ static int write_loop(snd_pcm_t *handle, int channel, int periods, uint8_t *fram
   double phase = 0;
   int    err, n;
 
+  fflush(stdout);
   if (test_type == TEST_WAV) {
     int bufsize = snd_pcm_frames_to_bytes(handle, period_size);
     n = 0;
-- 
1.7.6

From cdc496addb28784ae6bc43efc5afa67cba073fde Mon Sep 17 00:00:00 2001
From: Clemens Ladisch <clemens@ladisch.de>
Date: Mon, 1 Feb 2010 13:22:39 +0100
Subject: [PATCH] amixer: fix display of unreadable control elements

When an element is marked as not readble, do not try to read it and then
complain about the error, but just ignore it.

Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
---
 amixer/amixer.c |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)

diff --git a/amixer/amixer.c b/amixer/amixer.c
index 9620721..7b55035 100644
--- a/amixer/amixer.c
+++ b/amixer/amixer.c
@@ -602,6 +602,8 @@ static int show_control(const char *space, snd_hctl_elem_t *elem,
 		break;
 	}
 	if (level & LEVEL_BASIC) {
+		if (!snd_ctl_elem_info_is_readable(info))
+			goto __skip_read;
 		if ((err = snd_hctl_elem_read(elem, control)) < 0) {
 			error("Control %s element read error: %s\n", card, snd_strerror(err));
 			return err;
@@ -638,6 +640,7 @@ static int show_control(const char *space, snd_hctl_elem_t *elem,
 			}
 		}
 		printf("\n");
+	      __skip_read:
 		if (!snd_ctl_elem_info_is_tlv_readable(info))
 			goto __skip_tlv;
 		tlv = malloc(4096);
-- 
1.7.6

From f45aa72cd6a71515494a70448d48608c2d25960e Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Wed, 10 Feb 2010 11:52:53 +0100
Subject: [PATCH] amixer: add support for TLV dB minmax types

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 amixer/amixer.c |   20 ++++++++++++++++++++
 1 files changed, 20 insertions(+), 0 deletions(-)

diff --git a/amixer/amixer.c b/amixer/amixer.c
index 7b55035..c9ea572 100644
--- a/amixer/amixer.c
+++ b/amixer/amixer.c
@@ -534,6 +534,26 @@ static void decode_tlv(unsigned int spaces, unsigned int *tlv, unsigned int tlv_
 		}
 		break;
 #endif
+#ifdef SND_CTL_TLVT_DB_MINMAX
+	case SND_CTL_TLVT_DB_MINMAX:
+	case SND_CTL_TLVT_DB_MINMAX_MUTE:
+		if (type == SND_CTL_TLVT_DB_MINMAX_MUTE)
+			printf("dBminmaxmute-");
+		else
+			printf("dBminmax-");
+		if (size != 2 * sizeof(unsigned int)) {
+			while (size > 0) {
+				printf("0x%08x,", tlv[idx++]);
+				size -= sizeof(unsigned int);
+			}
+		} else {
+			printf("min=");
+			print_dB(tlv[2]);
+			printf(",max=");
+			print_dB(tlv[3]);
+		}
+		break;
+#endif
 	default:
 		printf("unk-%i-", type);
 		while (size > 0) {
-- 
1.7.6

From 69c6bead434e7a4a546ab1300413312994b93e35 Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Sun, 14 Feb 2010 19:07:25 +0100
Subject: [PATCH] alsactl: Fix return code

The main() should return positive error value.

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 alsactl/alsactl.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/alsactl/alsactl.c b/alsactl/alsactl.c
index 02e082f..3b5dfda 100644
--- a/alsactl/alsactl.c
+++ b/alsactl/alsactl.c
@@ -189,5 +189,5 @@ int main(int argc, char *argv[])
 	}
 
 	snd_config_update_free_global();
-	return res < 0 ? res : 0;
+	return res < 0 ? -res : 0;
 }
-- 
1.7.6

From 5a016b583b5c949253a9e791ad79f13e54f87054 Mon Sep 17 00:00:00 2001
From: Clemens Ladisch <clemens@ladisch.de>
Date: Fri, 19 Feb 2010 17:07:20 +0100
Subject: [PATCH] alsamixer: fix division by zero

The attempt to divide by max-min fails if a control has only one valid
value.  In this case, adjust the maximum so that the computation can
succeed; the control will look like 0%.

Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
---
 alsamixer/mixer_display.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/alsamixer/mixer_display.c b/alsamixer/mixer_display.c
index 9eadcc9..260c9b0 100644
--- a/alsamixer/mixer_display.c
+++ b/alsamixer/mixer_display.c
@@ -462,6 +462,8 @@ static void display_control(unsigned int control_index)
 			err = snd_mixer_selem_get_capture_volume_range(control->elem, &min, &max);
 		if (err < 0)
 			return;
+		if (min == max)
+			max = min + 1;
 
 		if (control->flags & IS_ACTIVE)
 			wattrset(mixer_widget.window, 0);
-- 
1.7.6

From c9b86f49a8a1a8c337bf0c1b7f12749e8be781ed Mon Sep 17 00:00:00 2001
From: Clemens Ladisch <clemens@ladisch.de>
Date: Mon, 22 Feb 2010 09:42:03 +0100
Subject: [PATCH] alsamixer: handle out-of-range volume values

Ensure that control volume values are in their allowed range; otherwise,
the displayed values could be outside the range 0..100 and mess up the
layout.

Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
---
 alsamixer/mixer_display.c |   13 ++++++++++++-
 1 files changed, 12 insertions(+), 1 deletions(-)

diff --git a/alsamixer/mixer_display.c b/alsamixer/mixer_display.c
index 260c9b0..20d6d6a 100644
--- a/alsamixer/mixer_display.c
+++ b/alsamixer/mixer_display.c
@@ -390,6 +390,15 @@ static void display_string_centered_in_control(int y, int col, const char *s, in
 	display_string_in_field(y, x, s, width, ALIGN_CENTER);
 }
 
+static long clamp(long value, long min, long max)
+{
+	if (value < min)
+		return min;
+	if (value > max)
+		return max;
+	return value;
+}
+
 static void display_control(unsigned int control_index)
 {
 	struct control *control;
@@ -462,8 +471,10 @@ static void display_control(unsigned int control_index)
 			err = snd_mixer_selem_get_capture_volume_range(control->elem, &min, &max);
 		if (err < 0)
 			return;
-		if (min == max)
+		if (min >= max)
 			max = min + 1;
+		volumes[0] = clamp(volumes[0], min, max);
+		volumes[1] = clamp(volumes[1], min, max);
 
 		if (control->flags & IS_ACTIVE)
 			wattrset(mixer_widget.window, 0);
-- 
1.7.6

From 5c35aa8b69ae67caf094fb3f41a1b270d4eb5b2d Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Thu, 25 Feb 2010 09:19:45 +0100
Subject: [PATCH] alsactl: improve -d to get warnings and store exitcode to
 runstate file

Also, make the initialization & restore logic for one card similar to
multiple card initialization & restore.

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 alsactl/alsactl.h |   10 +++++-----
 alsactl/state.c   |   14 +++++++-------
 alsactl/utils.c   |    6 +++++-
 3 files changed, 17 insertions(+), 13 deletions(-)

diff --git a/alsactl/alsactl.h b/alsactl/alsactl.h
index 89ad295..be90efb 100644
--- a/alsactl/alsactl.h
+++ b/alsactl/alsactl.h
@@ -34,16 +34,16 @@ extern char *statefile;
 
 #if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95)
 #define cerror(cond, ...) do {\
-	if (cond) { \
-		fprintf(stderr, "%s: %s:%d: ", command, __FUNCTION__, __LINE__); \
+	if (cond || debugflag) { \
+		fprintf(stderr, "%s%s: %s:%d: ", debugflag ? "WARNING: " : "", command, __FUNCTION__, __LINE__); \
 		fprintf(stderr, __VA_ARGS__); \
 		putc('\n', stderr); \
 	} \
 } while (0)
 #else
 #define cerror(cond, args...) do {\
-	if (cond) { \
-		fprintf(stderr, "%s: %s:%d: ", command, __FUNCTION__, __LINE__); \
+	if (cond || debugflag) { \
+		fprintf(stderr, "%s%s: %s:%d: ", debugflag ? "WARNING: " : "", command, __FUNCTION__, __LINE__); \
 		fprintf(stderr, ##args); \
 		putc('\n', stderr); \
 	} \
@@ -78,7 +78,7 @@ int generate_names(const char *cfgfile);
 int file_map(const char *filename, char **buf, size_t *bufsize);
 void file_unmap(void *buf, size_t bufsize);
 size_t line_width(const char *buf, size_t bufsize, size_t pos);
-void initfailed(int cardnumber, const char *reason);
+void initfailed(int cardnumber, const char *reason, int exitcode);
 
 static inline int hextodigit(int c)
 {
diff --git a/alsactl/state.c b/alsactl/state.c
index 635a999..582fdf9 100644
--- a/alsactl/state.c
+++ b/alsactl/state.c
@@ -1582,9 +1582,9 @@ int load_state(const char *file, const char *initfile, const char *cardname,
 			err = init(initfile, cardname1);
 			if (err < 0) {
 				finalerr = err;
-				initfailed(card, "init");
+				initfailed(card, "init", err);
 			}
-			initfailed(card, "restore");
+			initfailed(card, "restore", -ENOENT);
 		}
 		if (first)
 			finalerr = 0;	/* no cards, no error code */
@@ -1617,14 +1617,14 @@ int load_state(const char *file, const char *initfile, const char *cardname,
 				sprintf(cardname1, "%i", card);
 				err = init(initfile, cardname1);
 				if (err < 0) {
-					initfailed(card, "init");
+					initfailed(card, "init", err);
 					finalerr = err;
 				}
 			}
 			if ((err = set_controls(card, config, 1))) {
 				if (!force_restore)
 					finalerr = err;
-				initfailed(card, "restore");
+				initfailed(card, "restore", err);
 			}
 		}
 	} else {
@@ -1639,12 +1639,12 @@ int load_state(const char *file, const char *initfile, const char *cardname,
 		if (do_init && set_controls(cardno, config, 0)) {
 			err = init(initfile, cardname);
 			if (err < 0) {
-				initfailed(cardno, "init");
-				return err;
+				initfailed(cardno, "init", err);
+				finalerr = err;
 			}
 		}
 		if ((err = set_controls(cardno, config, 1))) {
-			initfailed(cardno, "restore");
+			initfailed(cardno, "restore", err);
 			if (!force_restore)
 				return err;
 		}
diff --git a/alsactl/utils.c b/alsactl/utils.c
index ab4dbd4..a27eb6e 100644
--- a/alsactl/utils.c
+++ b/alsactl/utils.c
@@ -79,19 +79,23 @@ size_t line_width(const char *buf, size_t bufsize, size_t pos)
 	return count - pos;
 }
 
-void initfailed(int cardnumber, const char *reason)
+void initfailed(int cardnumber, const char *reason, int exitcode)
 {
 	int fp;
 	char *str;
+	char sexitcode[16];
 
 	if (statefile == NULL)
 		return;
 	if (snd_card_get_name(cardnumber, &str) < 0)
 		return;
+	sprintf(sexitcode, "%i", exitcode);
 	fp = open(statefile, O_WRONLY|O_CREAT|O_APPEND, 0644);
 	write(fp, str, strlen(str));
 	write(fp, ":", 1);
 	write(fp, reason, strlen(reason));
+	write(fp, ":", 1);
+	write(fp, sexitcode, strlen(sexitcode));
 	write(fp, "\n", 1);
 	close(fp);
 	free(str);
-- 
1.7.6

From 412cb29b587f520834979b017412d086254e11c2 Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Thu, 25 Feb 2010 15:01:29 +0100
Subject: [PATCH] alsactl: add more debug prints to state.c

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 alsactl/state.c |    4 +++-
 1 files changed, 3 insertions(+), 1 deletions(-)

diff --git a/alsactl/state.c b/alsactl/state.c
index 582fdf9..a59d084 100644
--- a/alsactl/state.c
+++ b/alsactl/state.c
@@ -1117,7 +1117,6 @@ static int restore_config_value2(snd_ctl_t *handle, snd_ctl_elem_info_t *info,
 		}
 		snd_ctl_elem_value_set_byte(ctl, idx, val);
 		return 1;
-		break;
 	default:
 		break;
 	}
@@ -1404,6 +1403,7 @@ static int set_controls(int card, snd_config_t *top, int doit)
 	snd_ctl_card_info_alloca(&info);
 
 	sprintf(name, "hw:%d", card);
+	dbg("device='%s', doit=%i", name, doit);
 	err = snd_ctl_open(&handle, name, 0);
 	if (err < 0) {
 		error("snd_ctl_open error: %s", snd_strerror(err));
@@ -1452,12 +1452,14 @@ static int set_controls(int card, snd_config_t *top, int doit)
 			/* not very informative */
 			/* but value is used for check only */
 			err = -EAGAIN;
+			dbg("maxnumid=%i: more controls?", maxnumid);
 			goto _close;
 		}
 	}
 
  _close:
 	snd_ctl_close(handle);
+	dbg("result code: %i", err);
 	return err;
 }
 
-- 
1.7.6

From f0658f37dc1c416e8f8415971b44afd6977ceb5c Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Thu, 25 Feb 2010 16:45:13 +0100
Subject: [PATCH] alsactl: update debug prints in state.c

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 alsactl/state.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/alsactl/state.c b/alsactl/state.c
index a59d084..e70c6f9 100644
--- a/alsactl/state.c
+++ b/alsactl/state.c
@@ -1415,6 +1415,7 @@ static int set_controls(int card, snd_config_t *top, int doit)
 		goto _close;
 	}
 	id = snd_ctl_card_info_get_id(info);
+	dbg("card-info-id: '%s'", id);
 	err = snd_config_searchv(top, &control, "state", id, "control", 0);
 	if (err < 0) {
 		if (force_restore) {
@@ -1440,19 +1441,18 @@ static int set_controls(int card, snd_config_t *top, int doit)
 			goto _close;
 	}
 
+	dbg("maxnumid=%i", maxnumid);
 	/* check if we have additional controls in driver */
 	/* in this case we should go through init procedure */
 	if (!doit && maxnumid >= 0) {
-		snd_ctl_elem_id_t *id;
 		snd_ctl_elem_info_t *info;
-		snd_ctl_elem_id_alloca(&id);
 		snd_ctl_elem_info_alloca(&info);
 		snd_ctl_elem_info_set_numid(info, maxnumid+1);
 		if (snd_ctl_elem_info(handle, info) == 0) {
 			/* not very informative */
 			/* but value is used for check only */
 			err = -EAGAIN;
-			dbg("maxnumid=%i: more controls?", maxnumid);
+			dbg("more controls than maxnumid?");
 			goto _close;
 		}
 	}
-- 
1.7.6

From b5f5ebcbe68e92d623e8ca4978042f648aa218cd Mon Sep 17 00:00:00 2001
From: lieven moors <lievenmoors@gmail.com>
Date: Mon, 15 Mar 2010 18:13:11 +0100
Subject: [PATCH] aconnect -x: Do not update index after removal of
 connection.

Signed-off-by: lieven moors <lievenmoors@gmail.com>
Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 seq/aconnect/aconnect.c |   49 ++++++++++++++--------------------------------
 1 files changed, 15 insertions(+), 34 deletions(-)

diff --git a/seq/aconnect/aconnect.c b/seq/aconnect/aconnect.c
index 1a50666..8c66cfd 100644
--- a/seq/aconnect/aconnect.c
+++ b/seq/aconnect/aconnect.c
@@ -192,52 +192,33 @@ static void remove_connection(snd_seq_t *seq, snd_seq_client_info_t *cinfo,
 			      snd_seq_port_info_t *pinfo, int count)
 {
 	snd_seq_query_subscribe_t *query;
+	snd_seq_port_info_t *port;
+	snd_seq_port_subscribe_t *subs;
 
 	snd_seq_query_subscribe_alloca(&query);
 	snd_seq_query_subscribe_set_root(query, snd_seq_port_info_get_addr(pinfo));
-
 	snd_seq_query_subscribe_set_type(query, SND_SEQ_QUERY_SUBS_READ);
 	snd_seq_query_subscribe_set_index(query, 0);
-	for (; snd_seq_query_port_subscribers(seq, query) >= 0;
-	     snd_seq_query_subscribe_set_index(query, snd_seq_query_subscribe_get_index(query) + 1)) {
-		snd_seq_port_info_t *port;
-		snd_seq_port_subscribe_t *subs;
+
+	snd_seq_port_info_alloca(&port);
+	snd_seq_port_subscribe_alloca(&subs);
+
+	while (snd_seq_query_port_subscribers(seq, query) >= 0) {
 		const snd_seq_addr_t *sender = snd_seq_query_subscribe_get_root(query);
 		const snd_seq_addr_t *dest = snd_seq_query_subscribe_get_addr(query);
-		snd_seq_port_info_alloca(&port);
-		if (snd_seq_get_any_port_info(seq, dest->client, dest->port, port) < 0)
-			continue;
-		if (!(snd_seq_port_info_get_capability(port) & SND_SEQ_PORT_CAP_SUBS_WRITE))
-			continue;
-		if (snd_seq_port_info_get_capability(port) & SND_SEQ_PORT_CAP_NO_EXPORT)
-			continue;
-		snd_seq_port_subscribe_alloca(&subs);
-		snd_seq_port_subscribe_set_queue(subs, snd_seq_query_subscribe_get_queue(query));
-		snd_seq_port_subscribe_set_sender(subs, sender);
-		snd_seq_port_subscribe_set_dest(subs, dest);
-		snd_seq_unsubscribe_port(seq, subs);
-	}
 
-	snd_seq_query_subscribe_set_type(query, SND_SEQ_QUERY_SUBS_WRITE);
-	snd_seq_query_subscribe_set_index(query, 0);
-	for (; snd_seq_query_port_subscribers(seq, query) >= 0;
-	     snd_seq_query_subscribe_set_index(query, snd_seq_query_subscribe_get_index(query) + 1)) {
-		snd_seq_port_info_t *port;
-		snd_seq_port_subscribe_t *subs;
-		const snd_seq_addr_t *dest = snd_seq_query_subscribe_get_root(query);
-		const snd_seq_addr_t *sender = snd_seq_query_subscribe_get_addr(query);
-		snd_seq_port_info_alloca(&port);
-		if (snd_seq_get_any_port_info(seq, sender->client, sender->port, port) < 0)
-			continue;
-		if (!(snd_seq_port_info_get_capability(port) & SND_SEQ_PORT_CAP_SUBS_READ))
+		if (snd_seq_get_any_port_info(seq, dest->client, dest->port, port) < 0 ||
+		    !(snd_seq_port_info_get_capability(port) & SND_SEQ_PORT_CAP_SUBS_WRITE) ||
+		    (snd_seq_port_info_get_capability(port) & SND_SEQ_PORT_CAP_NO_EXPORT)) {
+			snd_seq_query_subscribe_set_index(query, snd_seq_query_subscribe_get_index(query) + 1);
 			continue;
-		if (snd_seq_port_info_get_capability(port) & SND_SEQ_PORT_CAP_NO_EXPORT)
-			continue;
-		snd_seq_port_subscribe_alloca(&subs);
+		}
 		snd_seq_port_subscribe_set_queue(subs, snd_seq_query_subscribe_get_queue(query));
 		snd_seq_port_subscribe_set_sender(subs, sender);
 		snd_seq_port_subscribe_set_dest(subs, dest);
-		snd_seq_unsubscribe_port(seq, subs);
+		if (snd_seq_unsubscribe_port(seq, subs) < 0) {
+			snd_seq_query_subscribe_set_index(query, snd_seq_query_subscribe_get_index(query) + 1);
+		}
 	}
 }
 
-- 
1.7.6

From e509df69a5100df28921980362488f6947df0aae Mon Sep 17 00:00:00 2001
From: Clemens Ladisch <clemens@ladisch.de>
Date: Wed, 26 May 2010 10:07:47 +0200
Subject: [PATCH] alsactl: use snd_config_imake* functions

To save a call to snd_config_set_xxx, replace the calls to
snd_config_make_xxx with snd_config_imake_xxx.

Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
---
 alsactl/alsactl.h       |   10 ++++----
 alsactl/state.c         |   43 ++++++++++++----------------------------
 alsactl/utils.c         |    6 +----
 configure.in            |    2 +-
 seq/aconnect/aconnect.c |   49 ++++++++++++++++++++++++++++++++--------------
 5 files changed, 54 insertions(+), 56 deletions(-)

diff --git a/alsactl/alsactl.h b/alsactl/alsactl.h
index be90efb..89ad295 100644
--- a/alsactl/alsactl.h
+++ b/alsactl/alsactl.h
@@ -34,16 +34,16 @@ extern char *statefile;
 
 #if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95)
 #define cerror(cond, ...) do {\
-	if (cond || debugflag) { \
-		fprintf(stderr, "%s%s: %s:%d: ", debugflag ? "WARNING: " : "", command, __FUNCTION__, __LINE__); \
+	if (cond) { \
+		fprintf(stderr, "%s: %s:%d: ", command, __FUNCTION__, __LINE__); \
 		fprintf(stderr, __VA_ARGS__); \
 		putc('\n', stderr); \
 	} \
 } while (0)
 #else
 #define cerror(cond, args...) do {\
-	if (cond || debugflag) { \
-		fprintf(stderr, "%s%s: %s:%d: ", debugflag ? "WARNING: " : "", command, __FUNCTION__, __LINE__); \
+	if (cond) { \
+		fprintf(stderr, "%s: %s:%d: ", command, __FUNCTION__, __LINE__); \
 		fprintf(stderr, ##args); \
 		putc('\n', stderr); \
 	} \
@@ -78,7 +78,7 @@ int generate_names(const char *cfgfile);
 int file_map(const char *filename, char **buf, size_t *bufsize);
 void file_unmap(void *buf, size_t bufsize);
 size_t line_width(const char *buf, size_t bufsize, size_t pos);
-void initfailed(int cardnumber, const char *reason, int exitcode);
+void initfailed(int cardnumber, const char *reason);
 
 static inline int hextodigit(int c)
 {
diff --git a/alsactl/state.c b/alsactl/state.c
index e70c6f9..a9ffeea 100644
--- a/alsactl/state.c
+++ b/alsactl/state.c
@@ -58,7 +58,7 @@ static int snd_config_integer_add(snd_config_t *father, char *id, long integer)
 {
 	int err;
 	snd_config_t *leaf;
-	err = snd_config_make_integer(&leaf, id);
+	err = snd_config_imake_integer(&leaf, id, integer);
 	if (err < 0)
 		return err;
 	err = snd_config_add(father, leaf);
@@ -66,11 +66,6 @@ static int snd_config_integer_add(snd_config_t *father, char *id, long integer)
 		snd_config_delete(leaf);
 		return err;
 	}
-	err = snd_config_set_integer(leaf, integer);
-	if (err < 0) {
-		snd_config_delete(leaf);
-		return err;
-	}
 	return 0;
 }
 
@@ -78,7 +73,7 @@ static int snd_config_integer64_add(snd_config_t *father, char *id, long long in
 {
 	int err;
 	snd_config_t *leaf;
-	err = snd_config_make_integer64(&leaf, id);
+	err = snd_config_imake_integer64(&leaf, id, integer);
 	if (err < 0)
 		return err;
 	err = snd_config_add(father, leaf);
@@ -86,11 +81,6 @@ static int snd_config_integer64_add(snd_config_t *father, char *id, long long in
 		snd_config_delete(leaf);
 		return err;
 	}
-	err = snd_config_set_integer64(leaf, integer);
-	if (err < 0) {
-		snd_config_delete(leaf);
-		return err;
-	}
 	return 0;
 }
 
@@ -98,7 +88,7 @@ static int snd_config_string_add(snd_config_t *father, const char *id, const cha
 {
 	int err;
 	snd_config_t *leaf;
-	err = snd_config_make_string(&leaf, id);
+	err = snd_config_imake_string(&leaf, id, string);
 	if (err < 0)
 		return err;
 	err = snd_config_add(father, leaf);
@@ -106,11 +96,6 @@ static int snd_config_string_add(snd_config_t *father, const char *id, const cha
 		snd_config_delete(leaf);
 		return err;
 	}
-	err = snd_config_set_string(leaf, string);
-	if (err < 0) {
-		snd_config_delete(leaf);
-		return err;
-	}
 	return 0;
 }
 
@@ -1117,6 +1102,7 @@ static int restore_config_value2(snd_ctl_t *handle, snd_ctl_elem_info_t *info,
 		}
 		snd_ctl_elem_value_set_byte(ctl, idx, val);
 		return 1;
+		break;
 	default:
 		break;
 	}
@@ -1403,7 +1389,6 @@ static int set_controls(int card, snd_config_t *top, int doit)
 	snd_ctl_card_info_alloca(&info);
 
 	sprintf(name, "hw:%d", card);
-	dbg("device='%s', doit=%i", name, doit);
 	err = snd_ctl_open(&handle, name, 0);
 	if (err < 0) {
 		error("snd_ctl_open error: %s", snd_strerror(err));
@@ -1415,7 +1400,6 @@ static int set_controls(int card, snd_config_t *top, int doit)
 		goto _close;
 	}
 	id = snd_ctl_card_info_get_id(info);
-	dbg("card-info-id: '%s'", id);
 	err = snd_config_searchv(top, &control, "state", id, "control", 0);
 	if (err < 0) {
 		if (force_restore) {
@@ -1441,25 +1425,24 @@ static int set_controls(int card, snd_config_t *top, int doit)
 			goto _close;
 	}
 
-	dbg("maxnumid=%i", maxnumid);
 	/* check if we have additional controls in driver */
 	/* in this case we should go through init procedure */
 	if (!doit && maxnumid >= 0) {
+		snd_ctl_elem_id_t *id;
 		snd_ctl_elem_info_t *info;
+		snd_ctl_elem_id_alloca(&id);
 		snd_ctl_elem_info_alloca(&info);
 		snd_ctl_elem_info_set_numid(info, maxnumid+1);
 		if (snd_ctl_elem_info(handle, info) == 0) {
 			/* not very informative */
 			/* but value is used for check only */
 			err = -EAGAIN;
-			dbg("more controls than maxnumid?");
 			goto _close;
 		}
 	}
 
  _close:
 	snd_ctl_close(handle);
-	dbg("result code: %i", err);
 	return err;
 }
 
@@ -1584,9 +1567,9 @@ int load_state(const char *file, const char *initfile, const char *cardname,
 			err = init(initfile, cardname1);
 			if (err < 0) {
 				finalerr = err;
-				initfailed(card, "init", err);
+				initfailed(card, "init");
 			}
-			initfailed(card, "restore", -ENOENT);
+			initfailed(card, "restore");
 		}
 		if (first)
 			finalerr = 0;	/* no cards, no error code */
@@ -1619,14 +1602,14 @@ int load_state(const char *file, const char *initfile, const char *cardname,
 				sprintf(cardname1, "%i", card);
 				err = init(initfile, cardname1);
 				if (err < 0) {
-					initfailed(card, "init", err);
+					initfailed(card, "init");
 					finalerr = err;
 				}
 			}
 			if ((err = set_controls(card, config, 1))) {
 				if (!force_restore)
 					finalerr = err;
-				initfailed(card, "restore", err);
+				initfailed(card, "restore");
 			}
 		}
 	} else {
@@ -1641,12 +1624,12 @@ int load_state(const char *file, const char *initfile, const char *cardname,
 		if (do_init && set_controls(cardno, config, 0)) {
 			err = init(initfile, cardname);
 			if (err < 0) {
-				initfailed(cardno, "init", err);
-				finalerr = err;
+				initfailed(cardno, "init");
+				return err;
 			}
 		}
 		if ((err = set_controls(cardno, config, 1))) {
-			initfailed(cardno, "restore", err);
+			initfailed(cardno, "restore");
 			if (!force_restore)
 				return err;
 		}
diff --git a/alsactl/utils.c b/alsactl/utils.c
index a27eb6e..ab4dbd4 100644
--- a/alsactl/utils.c
+++ b/alsactl/utils.c
@@ -79,23 +79,19 @@ size_t line_width(const char *buf, size_t bufsize, size_t pos)
 	return count - pos;
 }
 
-void initfailed(int cardnumber, const char *reason, int exitcode)
+void initfailed(int cardnumber, const char *reason)
 {
 	int fp;
 	char *str;
-	char sexitcode[16];
 
 	if (statefile == NULL)
 		return;
 	if (snd_card_get_name(cardnumber, &str) < 0)
 		return;
-	sprintf(sexitcode, "%i", exitcode);
 	fp = open(statefile, O_WRONLY|O_CREAT|O_APPEND, 0644);
 	write(fp, str, strlen(str));
 	write(fp, ":", 1);
 	write(fp, reason, strlen(reason));
-	write(fp, ":", 1);
-	write(fp, sexitcode, strlen(sexitcode));
 	write(fp, "\n", 1);
 	close(fp);
 	free(str);
diff --git a/seq/aconnect/aconnect.c b/seq/aconnect/aconnect.c
index 8c66cfd..1a50666 100644
--- a/seq/aconnect/aconnect.c
+++ b/seq/aconnect/aconnect.c
@@ -192,33 +192,52 @@ static void remove_connection(snd_seq_t *seq, snd_seq_client_info_t *cinfo,
 			      snd_seq_port_info_t *pinfo, int count)
 {
 	snd_seq_query_subscribe_t *query;
-	snd_seq_port_info_t *port;
-	snd_seq_port_subscribe_t *subs;
 
 	snd_seq_query_subscribe_alloca(&query);
 	snd_seq_query_subscribe_set_root(query, snd_seq_port_info_get_addr(pinfo));
+
 	snd_seq_query_subscribe_set_type(query, SND_SEQ_QUERY_SUBS_READ);
 	snd_seq_query_subscribe_set_index(query, 0);
-
-	snd_seq_port_info_alloca(&port);
-	snd_seq_port_subscribe_alloca(&subs);
-
-	while (snd_seq_query_port_subscribers(seq, query) >= 0) {
+	for (; snd_seq_query_port_subscribers(seq, query) >= 0;
+	     snd_seq_query_subscribe_set_index(query, snd_seq_query_subscribe_get_index(query) + 1)) {
+		snd_seq_port_info_t *port;
+		snd_seq_port_subscribe_t *subs;
 		const snd_seq_addr_t *sender = snd_seq_query_subscribe_get_root(query);
 		const snd_seq_addr_t *dest = snd_seq_query_subscribe_get_addr(query);
+		snd_seq_port_info_alloca(&port);
+		if (snd_seq_get_any_port_info(seq, dest->client, dest->port, port) < 0)
+			continue;
+		if (!(snd_seq_port_info_get_capability(port) & SND_SEQ_PORT_CAP_SUBS_WRITE))
+			continue;
+		if (snd_seq_port_info_get_capability(port) & SND_SEQ_PORT_CAP_NO_EXPORT)
+			continue;
+		snd_seq_port_subscribe_alloca(&subs);
+		snd_seq_port_subscribe_set_queue(subs, snd_seq_query_subscribe_get_queue(query));
+		snd_seq_port_subscribe_set_sender(subs, sender);
+		snd_seq_port_subscribe_set_dest(subs, dest);
+		snd_seq_unsubscribe_port(seq, subs);
+	}
 
-		if (snd_seq_get_any_port_info(seq, dest->client, dest->port, port) < 0 ||
-		    !(snd_seq_port_info_get_capability(port) & SND_SEQ_PORT_CAP_SUBS_WRITE) ||
-		    (snd_seq_port_info_get_capability(port) & SND_SEQ_PORT_CAP_NO_EXPORT)) {
-			snd_seq_query_subscribe_set_index(query, snd_seq_query_subscribe_get_index(query) + 1);
+	snd_seq_query_subscribe_set_type(query, SND_SEQ_QUERY_SUBS_WRITE);
+	snd_seq_query_subscribe_set_index(query, 0);
+	for (; snd_seq_query_port_subscribers(seq, query) >= 0;
+	     snd_seq_query_subscribe_set_index(query, snd_seq_query_subscribe_get_index(query) + 1)) {
+		snd_seq_port_info_t *port;
+		snd_seq_port_subscribe_t *subs;
+		const snd_seq_addr_t *dest = snd_seq_query_subscribe_get_root(query);
+		const snd_seq_addr_t *sender = snd_seq_query_subscribe_get_addr(query);
+		snd_seq_port_info_alloca(&port);
+		if (snd_seq_get_any_port_info(seq, sender->client, sender->port, port) < 0)
 			continue;
-		}
+		if (!(snd_seq_port_info_get_capability(port) & SND_SEQ_PORT_CAP_SUBS_READ))
+			continue;
+		if (snd_seq_port_info_get_capability(port) & SND_SEQ_PORT_CAP_NO_EXPORT)
+			continue;
+		snd_seq_port_subscribe_alloca(&subs);
 		snd_seq_port_subscribe_set_queue(subs, snd_seq_query_subscribe_get_queue(query));
 		snd_seq_port_subscribe_set_sender(subs, sender);
 		snd_seq_port_subscribe_set_dest(subs, dest);
-		if (snd_seq_unsubscribe_port(seq, subs) < 0) {
-			snd_seq_query_subscribe_set_index(query, snd_seq_query_subscribe_get_index(query) + 1);
-		}
+		snd_seq_unsubscribe_port(seq, subs);
 	}
 }
 
-- 
1.7.6

From ad47784b01b9dd532ba2c2249547ce55505bbf08 Mon Sep 17 00:00:00 2001
From: Clemens Ladisch <clemens@ladisch.de>
Date: Wed, 26 May 2010 10:18:43 +0200
Subject: [PATCH] alsactl: move alloca out of loop

Reserving new space from the stack in every loop iteration is not
necessary, so move the call to snd_ctl_elem_id_alloca outside where it
is executed only once.

Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
---
 alsactl/state.c |    8 ++++----
 1 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/alsactl/state.c b/alsactl/state.c
index a9ffeea..86f7748 100644
--- a/alsactl/state.c
+++ b/alsactl/state.c
@@ -523,6 +523,7 @@ static int get_controls(int cardno, snd_config_t *top)
 	snd_ctl_card_info_t *info;
 	snd_config_t *state, *card, *control;
 	snd_ctl_elem_list_t *list;
+	snd_ctl_elem_id_t *elem_id;
 	unsigned int idx;
 	int err;
 	char name[32];
@@ -530,6 +531,7 @@ static int get_controls(int cardno, snd_config_t *top)
 	const char *id;
 	snd_ctl_card_info_alloca(&info);
 	snd_ctl_elem_list_alloca(&list);
+	snd_ctl_elem_id_alloca(&elem_id);
 
 	sprintf(name, "hw:%d", cardno);
 	err = snd_ctl_open(&handle, name, SND_CTL_READONLY);
@@ -604,10 +606,8 @@ static int get_controls(int cardno, snd_config_t *top)
 		goto _free;
 	}
 	for (idx = 0; idx < count; ++idx) {
-		snd_ctl_elem_id_t *id;
-		snd_ctl_elem_id_alloca(&id);
-		snd_ctl_elem_list_get_id(list, idx, id);
-		err = get_control(handle, id, control);
+		snd_ctl_elem_list_get_id(list, idx, elem_id);
+		err = get_control(handle, elem_id, control);
 		if (err < 0)
 			goto _free;
 	}		
-- 
1.7.6

From 224c12238e484ec795ace29bf5ff712dbae21633 Mon Sep 17 00:00:00 2001
From: Clemens Ladisch <clemens@ladisch.de>
Date: Wed, 26 May 2010 10:19:17 +0200
Subject: [PATCH] alsactl: remove open-coded search

Remove search_comment_item since it does the same as snd_config_search.

Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
---
 alsactl/state.c |   30 +++++-------------------------
 1 files changed, 5 insertions(+), 25 deletions(-)

diff --git a/alsactl/state.c b/alsactl/state.c
index 86f7748..815345a 100644
--- a/alsactl/state.c
+++ b/alsactl/state.c
@@ -900,31 +900,14 @@ static int add_user_control(snd_ctl_t *handle, snd_ctl_elem_info_t *info, snd_co
 }
 
 /*
- * look for a config node with the given item name
- */
-static snd_config_t *search_comment_item(snd_config_t *conf, const char *name)
-{
-	snd_config_iterator_t i, next;
-	snd_config_for_each(i, next, conf) {
-		snd_config_t *n = snd_config_iterator_entry(i);
-		const char *id;
-		if (snd_config_get_id(n, &id) < 0)
-			continue;
-		if (strcmp(id, name) == 0)
-			return n;
-	}
-	return NULL;
-}
-
-/*
  * check whether the config item has the same of compatible type
  */
 static int check_comment_type(snd_config_t *conf, int type)
 {
-	snd_config_t *n = search_comment_item(conf, "type");
+	snd_config_t *n;
 	int ctype;
 
-	if (!n)
+	if (snd_config_search(conf, "type", &n) < 0)
 		return 0; /* not defined */
 	ctype = get_comment_type(n);
 	if (ctype == type)
@@ -980,8 +963,7 @@ static int check_comment_range(snd_ctl_t *handle, snd_config_t *conf,
 	long ndbmin, ndbmax;
 	snd_ctl_elem_id_t *id;
 
-	n = search_comment_item(conf, "range");
-	if (!n)
+	if (snd_config_search(conf, "range", &n) < 0)
 		return 0;
 	if (get_comment_range(n, SND_CTL_ELEM_TYPE_INTEGER,
 			      &omin, &omax, &ostep) < 0)
@@ -996,13 +978,11 @@ static int check_comment_range(snd_ctl_t *handle, snd_config_t *conf,
 	if (omin >= omax || nmin >= nmax)
 		return 0; /* invalid values */
 
-	n = search_comment_item(conf, "dbmin");
-	if (!n)
+	if (snd_config_search(conf, "dbmin", &n) < 0)
 		return 0;
 	if (config_integer(n, &odbmin, doit) < 0)
 		return 0;
-	n = search_comment_item(conf, "dbmax");
-	if (!n)
+	if (snd_config_search(conf, "dbmax", &n) < 0)
 		return 0;
 	if (config_integer(n, &odbmax, doit) < 0)
 		return 0;
-- 
1.7.6

From 4f29877d54f9132219261218c2357e2b6e8910f4 Mon Sep 17 00:00:00 2001
From: Clemens Ladisch <clemens@ladisch.de>
Date: Wed, 26 May 2010 10:27:25 +0200
Subject: [PATCH] alsactl: correctly restore dB values of controls with
 changed range

When the range of a control has changed between driver versions, it is a
good idea to restore the same dB value of the control.  However,
computing the dB value by interpolating betweem the min/max dB values
duplicates alsa-lib's TLV functions and does not even work for controls
with a linear dB range.

A simple conversion to dB and back can be done if we add the dB value(s)
to the saved state.

Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
---
 alsactl/state.c |   85 +++++++++++++++++++++++++++++++++++++++++-------------
 1 files changed, 64 insertions(+), 21 deletions(-)

diff --git a/alsactl/state.c b/alsactl/state.c
index 815345a..538fa82 100644
--- a/alsactl/state.c
+++ b/alsactl/state.c
@@ -164,14 +164,18 @@ static unsigned int *str_to_tlv(const char *s)
 }
 
 /*
- * add the TLV string and dB ranges to comment fields
+ * add the TLV string, dB ranges, and dB values to comment fields
  */
 static int add_tlv_comments(snd_ctl_t *handle, snd_ctl_elem_id_t *id,
-			    snd_ctl_elem_info_t *info, snd_config_t *comment)
+			    snd_ctl_elem_info_t *info, snd_ctl_elem_value_t *ctl,
+			    snd_config_t *comment)
 {
 	unsigned int tlv[MAX_USER_TLV_SIZE];
 	unsigned int *db;
-	long dbmin, dbmax;
+	long rangemin, rangemax;
+	long dbmin, dbmax, dbgain;
+	snd_config_t *value;
+	unsigned int i, count;
 	int err;
 
 	if (snd_ctl_elem_tlv_read(handle, id, tlv, sizeof(tlv)) < 0)
@@ -193,13 +197,35 @@ static int add_tlv_comments(snd_ctl_t *handle, snd_ctl_elem_id_t *id,
 	if (err <= 0)
 		return 0;
 
-	snd_tlv_get_dB_range(db, snd_ctl_elem_info_get_min(info),
-			     snd_ctl_elem_info_get_max(info),
-			     &dbmin, &dbmax);
+	rangemin = snd_ctl_elem_info_get_min(info);
+	rangemax = snd_ctl_elem_info_get_max(info);
+	snd_tlv_get_dB_range(db, rangemin, rangemax, &dbmin, &dbmax);
 	if (err < 0)
 		return err;
 	snd_config_integer_add(comment, "dbmin", dbmin);
 	snd_config_integer_add(comment, "dbmax", dbmax);
+
+	if (snd_ctl_elem_info_get_type(info) == SND_CTL_ELEM_TYPE_INTEGER) {
+		err = snd_config_compound_add(comment, "dbvalue", 1, &value);
+		if (err < 0) {
+			error("snd_config_compound_add: %s", snd_strerror(err));
+			return err;
+		}
+		count = snd_ctl_elem_info_get_count(info);
+		for (i = 0; i < count; i++) {
+			err = snd_tlv_convert_to_dB(db, rangemin, rangemax,
+					snd_ctl_elem_value_get_integer(ctl, i), &dbgain);
+			if (err < 0) {
+				error("snd_tlv_convert_to_dB: %s", snd_strerror(err));
+				return err;
+			}
+			err = snd_config_integer_add(value, num_str(i), dbgain);
+			if (err < 0) {
+				error("snd_config_integer_add: %s", snd_strerror(err));
+				return err;
+			}
+		}
+	}
 	return 0;
 }
 
@@ -302,7 +328,7 @@ static int get_control(snd_ctl_t *handle, snd_ctl_elem_id_t *id, snd_config_t *t
 			return err;
 		}
 		if (snd_ctl_elem_info_is_tlv_readable(info)) {
-			err = add_tlv_comments(handle, id, info, comment);
+			err = add_tlv_comments(handle, id, info, ctl, comment);
 			if (err < 0)
 				return err;
 		}
@@ -930,20 +956,31 @@ static int check_comment_type(snd_config_t *conf, int type)
 static int convert_to_new_db(snd_config_t *value, long omin, long omax,
 			     long nmin, long nmax,
 			     long odbmin, long odbmax,
-			     long ndbmin, long ndbmax,
+			     snd_config_t *comment, const char *index,
+			     snd_ctl_t *device, snd_ctl_elem_id_t *id,
 			     int doit)
 {
-	long val;
-	if (config_integer(value, &val, doit) < 0)
-		return -EINVAL;
-	if (val < omin || val > omax)
-		return -EINVAL;
-	val = ((val - omin) * (odbmax - odbmin)) / (omax - omin) + odbmin;
-	if (val < ndbmin)
-		val = ndbmin;
-	else if (val > ndbmax)
-		val = ndbmax;
-	val = ((val - ndbmin) * (nmax - nmin)) / (ndbmax - ndbmin) + nmin;
+	snd_config_t *db_node;
+	long db, val;
+	int err;
+
+	if (snd_config_searchv(comment, &db_node, "dbvalue", index, NULL) < 0 ||
+	    snd_config_get_integer(db_node, &db) < 0) {
+		err = config_integer(value, &val, doit);
+		if (err < 0)
+			return err;
+		if (val < omin || val > omax)
+			return -EINVAL;
+		db = ((val - omin) * (odbmax - odbmin)) / (omax - omin) + odbmin;
+	}
+
+	err = snd_ctl_convert_from_dB(device, id, db, &val, db > 0);
+	if (err < 0)
+		return err;
+	if (val < nmin)
+		val = nmin;
+	else if (val > nmax)
+		val = nmax;
 	return snd_config_set_integer(value, val);
 }
 
@@ -961,6 +998,7 @@ static int check_comment_range(snd_ctl_t *handle, snd_config_t *conf,
 	long nmin, nmax;
 	long odbmin, odbmax;
 	long ndbmin, ndbmax;
+	long db;
 	snd_ctl_elem_id_t *id;
 
 	if (snd_config_search(conf, "range", &n) < 0)
@@ -1003,12 +1041,17 @@ static int check_comment_range(snd_ctl_t *handle, snd_config_t *conf,
 		snd_config_iterator_t i, next;
 		snd_config_for_each(i, next, value) {
 			snd_config_t *n = snd_config_iterator_entry(i);
+			const char *idxstr;
+			if (snd_config_get_id(n, &idxstr) < 0)
+				continue;
 			convert_to_new_db(n, omin, omax, nmin, nmax,
-					  odbmin, odbmax, ndbmin, ndbmax, doit);
+					  odbmin, odbmax, conf, idxstr,
+					  handle, id, doit);
 		}
 	} else
 		convert_to_new_db(value, omin, omax, nmin, nmax,
-				  odbmin, odbmax, ndbmin, ndbmax, doit);
+				  odbmin, odbmax, conf, "0",
+				  handle, id, doit);
 	return 0;
 }
 
-- 
1.7.6

From bd15b1e5ea23d25fcb2ccccd1cf25350c60fe527 Mon Sep 17 00:00:00 2001
From: Clemens Ladisch <clemens@ladisch.de>
Date: Wed, 26 May 2010 10:28:11 +0200
Subject: [PATCH] alsactl: change format of comment node in state file

Make the comment node a separate node in the state file (join=0), and
move it after the other fields of the respective control.

Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
---
 alsactl/state.c |   20 +++++++++++++-------
 1 files changed, 13 insertions(+), 7 deletions(-)

diff --git a/alsactl/state.c b/alsactl/state.c
index 538fa82..01b1cd6 100644
--- a/alsactl/state.c
+++ b/alsactl/state.c
@@ -266,9 +266,9 @@ static int get_control(snd_ctl_t *handle, snd_ctl_elem_id_t *id, snd_config_t *t
 		error("snd_config_compound_add: %s", snd_strerror(err));
 		return err;
 	}
-	err = snd_config_compound_add(control, "comment", 1, &comment);
+	err = snd_config_make_compound(&comment, "comment", 0);
 	if (err < 0) {
-		error("snd_config_compound_add: %s", snd_strerror(err));
+		error("snd_config_make_compound: %s", snd_strerror(err));
 		return err;
 	}
 
@@ -432,7 +432,7 @@ static int get_control(snd_ctl_t *handle, snd_ctl_elem_id_t *id, snd_config_t *t
 			error("snd_config_string_add: %s", snd_strerror(err));
 			return err;
 		}
-		return 0;
+		goto finish;
 	}
 	default:
 		break;
@@ -446,21 +446,21 @@ static int get_control(snd_ctl_t *handle, snd_ctl_elem_id_t *id, snd_config_t *t
 				error("snd_config_string_add: %s", snd_strerror(err));
 				return err;
 			}
-			return 0;
+			goto finish;
 		case SND_CTL_ELEM_TYPE_INTEGER:
 			err = snd_config_integer_add(control, "value", snd_ctl_elem_value_get_integer(ctl, 0));
 			if (err < 0) {
 				error("snd_config_integer_add: %s", snd_strerror(err));
 				return err;
 			}
-			return 0;
+			goto finish;
 		case SND_CTL_ELEM_TYPE_INTEGER64:
 			err = snd_config_integer64_add(control, "value", snd_ctl_elem_value_get_integer64(ctl, 0));
 			if (err < 0) {
 				error("snd_config_integer64_add: %s", snd_strerror(err));
 				return err;
 			}
-			return 0;
+			goto finish;
 		case SND_CTL_ELEM_TYPE_ENUMERATED:
 		{
 			unsigned int v = snd_ctl_elem_value_get_enumerated(ctl, 0);
@@ -475,7 +475,7 @@ static int get_control(snd_ctl_t *handle, snd_ctl_elem_id_t *id, snd_config_t *t
 			}
 			if (err < 0)
 				error("snd_config add: %s", snd_strerror(err));
-			return 0;
+			goto finish;
 		}
 		default:
 			error("Unknown control type: %d\n", type);
@@ -540,6 +540,12 @@ static int get_control(snd_ctl_t *handle, snd_ctl_elem_id_t *id, snd_config_t *t
 		return -EINVAL;
 	}
 	
+finish:
+	err = snd_config_add(control, comment);
+	if (err < 0) {
+		error("snd_config_add: %s", snd_strerror(err));
+		return err;
+	}
 	return 0;
 }
 	
-- 
1.7.6

From b4ff58b685fe9da25901cd3e395dd2f2d64532df Mon Sep 17 00:00:00 2001
From: Clemens Ladisch <clemens@ladisch.de>
Date: Wed, 26 May 2010 10:37:58 +0200
Subject: [PATCH] Revert wrong parts of "alsactl: use snd_config_imake*
 functions"

This reverts the parts of commit e509df69a5100df28921980362488f6947df0aae
that accidentally reverted a bunch of earlier commits.

Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
---
 alsactl/alsactl.h       |   10 ++++----
 alsactl/state.c         |   22 +++++++++++---------
 alsactl/utils.c         |    6 ++++-
 configure.in            |    2 +-
 seq/aconnect/aconnect.c |   49 ++++++++++++++--------------------------------
 5 files changed, 38 insertions(+), 51 deletions(-)

diff --git a/alsactl/alsactl.h b/alsactl/alsactl.h
index 89ad295..be90efb 100644
--- a/alsactl/alsactl.h
+++ b/alsactl/alsactl.h
@@ -34,16 +34,16 @@ extern char *statefile;
 
 #if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95)
 #define cerror(cond, ...) do {\
-	if (cond) { \
-		fprintf(stderr, "%s: %s:%d: ", command, __FUNCTION__, __LINE__); \
+	if (cond || debugflag) { \
+		fprintf(stderr, "%s%s: %s:%d: ", debugflag ? "WARNING: " : "", command, __FUNCTION__, __LINE__); \
 		fprintf(stderr, __VA_ARGS__); \
 		putc('\n', stderr); \
 	} \
 } while (0)
 #else
 #define cerror(cond, args...) do {\
-	if (cond) { \
-		fprintf(stderr, "%s: %s:%d: ", command, __FUNCTION__, __LINE__); \
+	if (cond || debugflag) { \
+		fprintf(stderr, "%s%s: %s:%d: ", debugflag ? "WARNING: " : "", command, __FUNCTION__, __LINE__); \
 		fprintf(stderr, ##args); \
 		putc('\n', stderr); \
 	} \
@@ -78,7 +78,7 @@ int generate_names(const char *cfgfile);
 int file_map(const char *filename, char **buf, size_t *bufsize);
 void file_unmap(void *buf, size_t bufsize);
 size_t line_width(const char *buf, size_t bufsize, size_t pos);
-void initfailed(int cardnumber, const char *reason);
+void initfailed(int cardnumber, const char *reason, int exitcode);
 
 static inline int hextodigit(int c)
 {
diff --git a/alsactl/state.c b/alsactl/state.c
index 01b1cd6..7eb107f 100644
--- a/alsactl/state.c
+++ b/alsactl/state.c
@@ -1131,7 +1131,6 @@ static int restore_config_value2(snd_ctl_t *handle, snd_ctl_elem_info_t *info,
 		}
 		snd_ctl_elem_value_set_byte(ctl, idx, val);
 		return 1;
-		break;
 	default:
 		break;
 	}
@@ -1418,6 +1417,7 @@ static int set_controls(int card, snd_config_t *top, int doit)
 	snd_ctl_card_info_alloca(&info);
 
 	sprintf(name, "hw:%d", card);
+	dbg("device='%s', doit=%i", name, doit);
 	err = snd_ctl_open(&handle, name, 0);
 	if (err < 0) {
 		error("snd_ctl_open error: %s", snd_strerror(err));
@@ -1429,6 +1429,7 @@ static int set_controls(int card, snd_config_t *top, int doit)
 		goto _close;
 	}
 	id = snd_ctl_card_info_get_id(info);
+	dbg("card-info-id: '%s'", id);
 	err = snd_config_searchv(top, &control, "state", id, "control", 0);
 	if (err < 0) {
 		if (force_restore) {
@@ -1454,24 +1455,25 @@ static int set_controls(int card, snd_config_t *top, int doit)
 			goto _close;
 	}
 
+	dbg("maxnumid=%i", maxnumid);
 	/* check if we have additional controls in driver */
 	/* in this case we should go through init procedure */
 	if (!doit && maxnumid >= 0) {
-		snd_ctl_elem_id_t *id;
 		snd_ctl_elem_info_t *info;
-		snd_ctl_elem_id_alloca(&id);
 		snd_ctl_elem_info_alloca(&info);
 		snd_ctl_elem_info_set_numid(info, maxnumid+1);
 		if (snd_ctl_elem_info(handle, info) == 0) {
 			/* not very informative */
 			/* but value is used for check only */
 			err = -EAGAIN;
+			dbg("more controls than maxnumid?");
 			goto _close;
 		}
 	}
 
  _close:
 	snd_ctl_close(handle);
+	dbg("result code: %i", err);
 	return err;
 }
 
@@ -1596,9 +1598,9 @@ int load_state(const char *file, const char *initfile, const char *cardname,
 			err = init(initfile, cardname1);
 			if (err < 0) {
 				finalerr = err;
-				initfailed(card, "init");
+				initfailed(card, "init", err);
 			}
-			initfailed(card, "restore");
+			initfailed(card, "restore", -ENOENT);
 		}
 		if (first)
 			finalerr = 0;	/* no cards, no error code */
@@ -1631,14 +1633,14 @@ int load_state(const char *file, const char *initfile, const char *cardname,
 				sprintf(cardname1, "%i", card);
 				err = init(initfile, cardname1);
 				if (err < 0) {
-					initfailed(card, "init");
+					initfailed(card, "init", err);
 					finalerr = err;
 				}
 			}
 			if ((err = set_controls(card, config, 1))) {
 				if (!force_restore)
 					finalerr = err;
-				initfailed(card, "restore");
+				initfailed(card, "restore", err);
 			}
 		}
 	} else {
@@ -1653,12 +1655,12 @@ int load_state(const char *file, const char *initfile, const char *cardname,
 		if (do_init && set_controls(cardno, config, 0)) {
 			err = init(initfile, cardname);
 			if (err < 0) {
-				initfailed(cardno, "init");
-				return err;
+				initfailed(cardno, "init", err);
+				finalerr = err;
 			}
 		}
 		if ((err = set_controls(cardno, config, 1))) {
-			initfailed(cardno, "restore");
+			initfailed(cardno, "restore", err);
 			if (!force_restore)
 				return err;
 		}
diff --git a/alsactl/utils.c b/alsactl/utils.c
index ab4dbd4..a27eb6e 100644
--- a/alsactl/utils.c
+++ b/alsactl/utils.c
@@ -79,19 +79,23 @@ size_t line_width(const char *buf, size_t bufsize, size_t pos)
 	return count - pos;
 }
 
-void initfailed(int cardnumber, const char *reason)
+void initfailed(int cardnumber, const char *reason, int exitcode)
 {
 	int fp;
 	char *str;
+	char sexitcode[16];
 
 	if (statefile == NULL)
 		return;
 	if (snd_card_get_name(cardnumber, &str) < 0)
 		return;
+	sprintf(sexitcode, "%i", exitcode);
 	fp = open(statefile, O_WRONLY|O_CREAT|O_APPEND, 0644);
 	write(fp, str, strlen(str));
 	write(fp, ":", 1);
 	write(fp, reason, strlen(reason));
+	write(fp, ":", 1);
+	write(fp, sexitcode, strlen(sexitcode));
 	write(fp, "\n", 1);
 	close(fp);
 	free(str);
diff --git a/configure.in b/configure.in
index 66b785f..8bae007 100644
--- a/configure.in
+++ b/configure.in
@@ -2,7 +2,7 @@ dnl Process this file with autoconf to produce a configure script.
 AC_PREREQ(2.59)
 AC_INIT(aplay/aplay.c)
 AC_PREFIX_DEFAULT(/usr)
-AM_INIT_AUTOMAKE(alsa-utils, 1.0.22)
+AM_INIT_AUTOMAKE(alsa-utils, 1.0.23)
 
 AM_GNU_GETTEXT([external])
 AM_GNU_GETTEXT_VERSION([0.15])
diff --git a/seq/aconnect/aconnect.c b/seq/aconnect/aconnect.c
index 1a50666..8c66cfd 100644
--- a/seq/aconnect/aconnect.c
+++ b/seq/aconnect/aconnect.c
@@ -192,52 +192,33 @@ static void remove_connection(snd_seq_t *seq, snd_seq_client_info_t *cinfo,
 			      snd_seq_port_info_t *pinfo, int count)
 {
 	snd_seq_query_subscribe_t *query;
+	snd_seq_port_info_t *port;
+	snd_seq_port_subscribe_t *subs;
 
 	snd_seq_query_subscribe_alloca(&query);
 	snd_seq_query_subscribe_set_root(query, snd_seq_port_info_get_addr(pinfo));
-
 	snd_seq_query_subscribe_set_type(query, SND_SEQ_QUERY_SUBS_READ);
 	snd_seq_query_subscribe_set_index(query, 0);
-	for (; snd_seq_query_port_subscribers(seq, query) >= 0;
-	     snd_seq_query_subscribe_set_index(query, snd_seq_query_subscribe_get_index(query) + 1)) {
-		snd_seq_port_info_t *port;
-		snd_seq_port_subscribe_t *subs;
+
+	snd_seq_port_info_alloca(&port);
+	snd_seq_port_subscribe_alloca(&subs);
+
+	while (snd_seq_query_port_subscribers(seq, query) >= 0) {
 		const snd_seq_addr_t *sender = snd_seq_query_subscribe_get_root(query);
 		const snd_seq_addr_t *dest = snd_seq_query_subscribe_get_addr(query);
-		snd_seq_port_info_alloca(&port);
-		if (snd_seq_get_any_port_info(seq, dest->client, dest->port, port) < 0)
-			continue;
-		if (!(snd_seq_port_info_get_capability(port) & SND_SEQ_PORT_CAP_SUBS_WRITE))
-			continue;
-		if (snd_seq_port_info_get_capability(port) & SND_SEQ_PORT_CAP_NO_EXPORT)
-			continue;
-		snd_seq_port_subscribe_alloca(&subs);
-		snd_seq_port_subscribe_set_queue(subs, snd_seq_query_subscribe_get_queue(query));
-		snd_seq_port_subscribe_set_sender(subs, sender);
-		snd_seq_port_subscribe_set_dest(subs, dest);
-		snd_seq_unsubscribe_port(seq, subs);
-	}
 
-	snd_seq_query_subscribe_set_type(query, SND_SEQ_QUERY_SUBS_WRITE);
-	snd_seq_query_subscribe_set_index(query, 0);
-	for (; snd_seq_query_port_subscribers(seq, query) >= 0;
-	     snd_seq_query_subscribe_set_index(query, snd_seq_query_subscribe_get_index(query) + 1)) {
-		snd_seq_port_info_t *port;
-		snd_seq_port_subscribe_t *subs;
-		const snd_seq_addr_t *dest = snd_seq_query_subscribe_get_root(query);
-		const snd_seq_addr_t *sender = snd_seq_query_subscribe_get_addr(query);
-		snd_seq_port_info_alloca(&port);
-		if (snd_seq_get_any_port_info(seq, sender->client, sender->port, port) < 0)
-			continue;
-		if (!(snd_seq_port_info_get_capability(port) & SND_SEQ_PORT_CAP_SUBS_READ))
+		if (snd_seq_get_any_port_info(seq, dest->client, dest->port, port) < 0 ||
+		    !(snd_seq_port_info_get_capability(port) & SND_SEQ_PORT_CAP_SUBS_WRITE) ||
+		    (snd_seq_port_info_get_capability(port) & SND_SEQ_PORT_CAP_NO_EXPORT)) {
+			snd_seq_query_subscribe_set_index(query, snd_seq_query_subscribe_get_index(query) + 1);
 			continue;
-		if (snd_seq_port_info_get_capability(port) & SND_SEQ_PORT_CAP_NO_EXPORT)
-			continue;
-		snd_seq_port_subscribe_alloca(&subs);
+		}
 		snd_seq_port_subscribe_set_queue(subs, snd_seq_query_subscribe_get_queue(query));
 		snd_seq_port_subscribe_set_sender(subs, sender);
 		snd_seq_port_subscribe_set_dest(subs, dest);
-		snd_seq_unsubscribe_port(seq, subs);
+		if (snd_seq_unsubscribe_port(seq, subs) < 0) {
+			snd_seq_query_subscribe_set_index(query, snd_seq_query_subscribe_get_index(query) + 1);
+		}
 	}
 }
 
-- 
1.7.6

From 3bd65336222a4d00cefc4db5e74a7a96c07ab567 Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Thu, 15 Jul 2010 10:40:21 +0200
Subject: [PATCH] aplay/arecord: Added hardware pause support (press SPACE or
 Enter)

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 aplay/aplay.c |   78 +++++++++++++++++++++++++++++++++++++++++++++++++++++---
 1 files changed, 73 insertions(+), 5 deletions(-)

diff --git a/aplay/aplay.c b/aplay/aplay.c
index e1d8e6a..b5203a7 100644
--- a/aplay/aplay.c
+++ b/aplay/aplay.c
@@ -41,6 +41,7 @@
 #include <locale.h>
 #include <alsa/asoundlib.h>
 #include <assert.h>
+#include <termios.h>
 #include <sys/poll.h>
 #include <sys/uio.h>
 #include <sys/time.h>
@@ -102,6 +103,7 @@ static int avail_min = -1;
 static int start_delay = 0;
 static int stop_delay = 0;
 static int monotonic = 0;
+static int can_pause = 0;
 static int verbose = 0;
 static int vumeter = VUMETER_NONE;
 static int buffer_pos = 0;
@@ -1111,6 +1113,7 @@ static void set_params(void)
 	}
 	assert(err >= 0);
 	monotonic = snd_pcm_hw_params_is_monotonic(params);
+	can_pause = snd_pcm_hw_params_can_pause(params);
 	err = snd_pcm_hw_params(handle, params);
 	if (err < 0) {
 		error(_("Unable to install hw params:"));
@@ -1182,7 +1185,7 @@ static void set_params(void)
 		int i;
 		err = snd_pcm_mmap_begin(handle, &areas, &offset, &size);
 		if (err < 0) {
-			error("snd_pcm_mmap_begin problem: %s", snd_strerror(err));
+			error(_("snd_pcm_mmap_begin problem: %s"), snd_strerror(err));
 			prg_exit(EXIT_FAILURE);
 		}
 		for (i = 0; i < hwparams.channels; i++)
@@ -1194,6 +1197,65 @@ static void set_params(void)
 	buffer_frames = buffer_size;	/* for position test */
 }
 
+static void init_stdin(void)
+{
+	struct termios term;
+	long flags;
+
+	if (fd == fileno(stdin))
+		return;
+	flags = fcntl(fileno(stdin), F_GETFL);
+	if (flags < 0 || fcntl(fileno(stdin), F_SETFL, flags|O_NONBLOCK) < 0)
+		fprintf(stderr, _("stdin O_NONBLOCK flag setup failed\n"));
+	tcgetattr(fileno(stdin), &term);
+	term.c_lflag &= ~ICANON;
+	tcsetattr(fileno(stdin), TCSANOW, &term);
+}
+
+static void do_pause(void)
+{
+	int err;
+	unsigned char b;
+
+	if (!can_pause) {
+		fprintf(stderr, _("\rPAUSE command ignored (no hw support)\n"));
+		return;
+	}
+	err = snd_pcm_pause(handle, 1);
+	if (err < 0) {
+		error(_("pause push error: %s"), snd_strerror(err));
+		return;
+	}
+	while (1) {
+		while (read(fileno(stdin), &b, 1) != 1);
+		if (b == ' ' || b == '\r') {
+			while (read(fileno(stdin), &b, 1) == 1);
+			err = snd_pcm_pause(handle, 0);
+			if (err < 0)
+				error(_("pause release error: %s"), snd_strerror(err));
+			return;
+		}
+	}
+}
+
+static void check_stdin(void)
+{
+	unsigned char b;
+
+	if (fd != fileno(stdin)) {
+		while (read(fileno(stdin), &b, 1) == 1) {
+			if (b == ' ' || b == '\r') {
+				while (read(fileno(stdin), &b, 1) == 1);
+				fprintf(stderr, _("\r=== PAUSE ===                                                            "));
+				fflush(stderr);
+			do_pause();
+				fprintf(stderr, "                                                                          \r");
+				fflush(stderr);
+			}
+		}
+	}
+}
+
 #ifndef timersub
 #define	timersub(a, b, result) \
 do { \
@@ -1589,12 +1651,13 @@ static ssize_t pcm_write(u_char *data, size_t count)
 	while (count > 0) {
 		if (test_position)
 			do_test_position();
+		check_stdin();
 		r = writei_func(handle, data, count);
 		if (test_position)
 			do_test_position();
 		if (r == -EAGAIN || (r >= 0 && (size_t)r < count)) {
 			if (!test_nowait)
-				snd_pcm_wait(handle, 1000);
+				snd_pcm_wait(handle, 100);
 		} else if (r == -EPIPE) {
 			xrun();
 		} else if (r == -ESTRPIPE) {
@@ -1635,12 +1698,13 @@ static ssize_t pcm_writev(u_char **data, unsigned int channels, size_t count)
 			bufs[channel] = data[channel] + offset * bits_per_sample / 8;
 		if (test_position)
 			do_test_position();
+		check_stdin();
 		r = writen_func(handle, bufs, count);
 		if (test_position)
 			do_test_position();
 		if (r == -EAGAIN || (r >= 0 && (size_t)r < count)) {
 			if (!test_nowait)
-				snd_pcm_wait(handle, 1000);
+				snd_pcm_wait(handle, 100);
 		} else if (r == -EPIPE) {
 			xrun();
 		} else if (r == -ESTRPIPE) {
@@ -1678,12 +1742,13 @@ static ssize_t pcm_read(u_char *data, size_t rcount)
 	while (count > 0) {
 		if (test_position)
 			do_test_position();
+		check_stdin();
 		r = readi_func(handle, data, count);
 		if (test_position)
 			do_test_position();
 		if (r == -EAGAIN || (r >= 0 && (size_t)r < count)) {
 			if (!test_nowait)
-				snd_pcm_wait(handle, 1000);
+				snd_pcm_wait(handle, 100);
 		} else if (r == -EPIPE) {
 			xrun();
 		} else if (r == -ESTRPIPE) {
@@ -1721,12 +1786,13 @@ static ssize_t pcm_readv(u_char **data, unsigned int channels, size_t rcount)
 			bufs[channel] = data[channel] + offset * bits_per_sample / 8;
 		if (test_position)
 			do_test_position();
+		check_stdin();
 		r = readn_func(handle, bufs, count);
 		if (test_position)
 			do_test_position();
 		if (r == -EAGAIN || (r >= 0 && (size_t)r < count)) {
 			if (!test_nowait)
-				snd_pcm_wait(handle, 1000);
+				snd_pcm_wait(handle, 100);
 		} else if (r == -EPIPE) {
 			xrun();
 		} else if (r == -ESTRPIPE) {
@@ -2361,6 +2427,7 @@ static void playback(char *name)
 		fd = fileno(stdin);
 		name = "stdin";
 	} else {
+		init_stdin();
 		if ((fd = open64(name, O_RDONLY, 0)) == -1) {
 			perror(name);
 			prg_exit(EXIT_FAILURE);
@@ -2616,6 +2683,7 @@ static void capture(char *orig_name)
 		if (count > fmt_rec_table[file_type].max_filesize)
 			count = fmt_rec_table[file_type].max_filesize;
 	}
+	init_stdin();
 
 	do {
 		/* open a file to write */
-- 
1.7.6

From 73c79ebf26a51a2d9b582a4cae82867873875743 Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Thu, 15 Jul 2010 13:39:14 +0200
Subject: [PATCH] aplay: fix termio settings - return back old c_flag value on
 exit

- symptom - ssh client password authentication does not work with
  the modified terminal settings

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 aplay/aplay.c |   18 +++++++++++++++++-
 1 files changed, 17 insertions(+), 1 deletions(-)

diff --git a/aplay/aplay.c b/aplay/aplay.c
index b5203a7..a92ca93 100644
--- a/aplay/aplay.c
+++ b/aplay/aplay.c
@@ -117,6 +117,7 @@ static long long max_file_size = 0;
 static int max_file_time = 0;
 static int use_strftime = 0;
 volatile static int recycle_capture_file = 0;
+static long term_c_lflag = 0;
 
 static int fd = -1;
 static off64_t pbrec_count = LLONG_MAX, fdcount;
@@ -128,6 +129,8 @@ static int pidfile_written = 0;
 
 /* needed prototypes */
 
+static void done_stdin(void);
+
 static void playback(char *filename);
 static void capture(char *filename);
 static void playbackv(char **filenames, unsigned int count);
@@ -343,6 +346,7 @@ static void version(void)
  */
 static void prg_exit(int code) 
 {
+	done_stdin();
 	if (handle)
 		snd_pcm_close(handle);
 	if (pidfile_written)
@@ -1202,16 +1206,28 @@ static void init_stdin(void)
 	struct termios term;
 	long flags;
 
+	tcgetattr(fileno(stdin), &term);
+	term_c_lflag = term.c_lflag;
 	if (fd == fileno(stdin))
 		return;
 	flags = fcntl(fileno(stdin), F_GETFL);
 	if (flags < 0 || fcntl(fileno(stdin), F_SETFL, flags|O_NONBLOCK) < 0)
 		fprintf(stderr, _("stdin O_NONBLOCK flag setup failed\n"));
-	tcgetattr(fileno(stdin), &term);
 	term.c_lflag &= ~ICANON;
 	tcsetattr(fileno(stdin), TCSANOW, &term);
 }
 
+static void done_stdin(void)
+{
+	struct termios term;
+
+	if (fd == fileno(stdin))
+		return;
+	tcgetattr(fileno(stdin), &term);
+	term.c_lflag = term_c_lflag;
+	tcsetattr(fileno(stdin), TCSANOW, &term);
+}
+
 static void do_pause(void)
 {
 	int err;
-- 
1.7.6

From 4c337275d1cc0579cc8ad45b4c138287e8658f0d Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Wed, 18 Aug 2010 08:22:23 +0200
Subject: [PATCH] speaker-test: add test pattern for PCM layer debugging
 purposes

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 speaker-test/speaker-test.c |   75 +++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 73 insertions(+), 2 deletions(-)

diff --git a/speaker-test/speaker-test.c b/speaker-test/speaker-test.c
index d8d68e2..458a8d7 100644
--- a/speaker-test/speaker-test.c
+++ b/speaker-test/speaker-test.c
@@ -63,7 +63,8 @@
 enum {
   TEST_PINK_NOISE = 1,
   TEST_SINE,
-  TEST_WAV
+  TEST_WAV,
+  TEST_PATTERN,
 };
 
 #define MAX_CHANNELS	16
@@ -303,6 +304,71 @@ static void generate_pink_noise( uint8_t *frames, int channel, int count) {
   }
 }
 
+/*
+ * useful for tests
+ */
+static void generate_pattern(uint8_t *frames, int channel, int count, int *_pattern) {
+  int pattern = *_pattern;
+  int    chn;
+  int8_t *samp8 = (int8_t*) frames;
+  int16_t *samp16 = (int16_t*) frames;
+  int32_t *samp32 = (int32_t*) frames;
+  float   *samp_f = (float*) frames;
+
+  while (count-- > 0) {
+    for(chn=0;chn<channels;chn++,pattern++) {
+      switch (format) {
+      case SND_PCM_FORMAT_S8:
+        if (chn==channel) {
+          *samp8++ = pattern & 0xff;
+        } else {
+          *samp8++ = 0;
+        }
+        break;
+      case SND_PCM_FORMAT_S16_LE:
+        if (chn==channel) {
+          *samp16++ = LE_SHORT(pattern & 0xfffff);
+        } else {
+          *samp16++ = 0;
+        }
+        break;
+      case SND_PCM_FORMAT_S16_BE:
+        if (chn==channel) {
+          *samp16++ = BE_SHORT(pattern & 0xffff);
+        } else {
+          *samp16++ = 0;
+        }
+        break;
+      case SND_PCM_FORMAT_FLOAT_LE:
+        if (chn==channel) {
+	  *samp_f++ = LE_INT(((double)pattern) / INT32_MAX);
+        } else {
+	  *samp_f++ = 0.0;
+        }
+        break;
+      case SND_PCM_FORMAT_S32_LE:
+        if (chn==channel) {
+          *samp32++ = LE_INT(pattern);
+        } else {
+          *samp32++ = 0;
+        }
+        break;
+      case SND_PCM_FORMAT_S32_BE:
+        if (chn==channel) {
+          *samp32++ = BE_INT(pattern);
+        } else {
+          *samp32++ = 0;
+        }
+        break;
+      default:
+        ;
+      }
+    }
+  }
+
+  *_pattern = pattern;
+}
+
 static int set_hwparams(snd_pcm_t *handle, snd_pcm_hw_params_t *params, snd_pcm_access_t access) {
   unsigned int rrate;
   int          err;
@@ -687,6 +753,7 @@ static int write_buffer(snd_pcm_t *handle, uint8_t *ptr, int cptr)
 static int write_loop(snd_pcm_t *handle, int channel, int periods, uint8_t *frames)
 {
   double phase = 0;
+  int	 pattern = 0;
   int    err, n;
 
   fflush(stdout);
@@ -713,6 +780,8 @@ static int write_loop(snd_pcm_t *handle, int channel, int periods, uint8_t *fram
   for(n = 0; n < periods; n++) {
     if (test_type == TEST_PINK_NOISE)
       generate_pink_noise(frames, channel, period_size);
+    else if (test_type == TEST_PATTERN)
+      generate_pattern(frames, channel, period_size, &pattern);
     else
       generate_sine(frames, channel, period_size, &phase);
 
@@ -860,9 +929,11 @@ int main(int argc, char *argv[]) {
 	test_type = TEST_SINE;
       else if (*optarg == 'w')
 	test_type = TEST_WAV;
+      else if (*optarg == 't')
+	test_type = TEST_PATTERN;
       else if (isdigit(*optarg)) {
 	test_type = atoi(optarg);
-	if (test_type < TEST_PINK_NOISE || test_type > TEST_WAV) {
+	if (test_type < TEST_PINK_NOISE || test_type > TEST_PATTERN) {
 	  fprintf(stderr, _("Invalid test type %s\n"), optarg);
 	  exit(1);
 	}
-- 
1.7.6

From bb865dc10b6dcee9d428d3c5a17ee312e0aaf7e0 Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Wed, 18 Aug 2010 08:23:09 +0200
Subject: [PATCH] aplay/arecord: term_c_lflag variable might be unitialized in
 some cases

The term_c_lflag variable might be unitialized in some cases. Add extra
check to avoid setting of wrong value.

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 aplay/aplay.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/aplay/aplay.c b/aplay/aplay.c
index a92ca93..c09f23c 100644
--- a/aplay/aplay.c
+++ b/aplay/aplay.c
@@ -117,7 +117,7 @@ static long long max_file_size = 0;
 static int max_file_time = 0;
 static int use_strftime = 0;
 volatile static int recycle_capture_file = 0;
-static long term_c_lflag = 0;
+static long term_c_lflag = -1;
 
 static int fd = -1;
 static off64_t pbrec_count = LLONG_MAX, fdcount;
@@ -1221,7 +1221,7 @@ static void done_stdin(void)
 {
 	struct termios term;
 
-	if (fd == fileno(stdin))
+	if (fd == fileno(stdin) || term_c_lflag == -1)
 		return;
 	tcgetattr(fileno(stdin), &term);
 	term.c_lflag = term_c_lflag;
-- 
1.7.6

From dcb90a779e74315596a4cdb4741983b21cba69c9 Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Thu, 2 Sep 2010 15:03:23 +0200
Subject: [PATCH] alsactl init: Use "Found hardware:" instead "Unknown
 hardware:"

It seems that "Unknown hardware:" confuses users. Use "Found hardware:"
instead.

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 alsactl/init/00main |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/alsactl/init/00main b/alsactl/init/00main
index 2d26bbf..fb7f02c 100644
--- a/alsactl/init/00main
+++ b/alsactl/init/00main
@@ -37,7 +37,7 @@ CARDINFO{driver}=="Test", INCLUDE="test", GOTO="init_end"
 LABEL="init_end"
 ACCESS=="postinit", INCLUDE="postinit"
 RESULT=="true", GOTO="00_mainend"
-ERROR="Unknown hardware: \"$cardinfo{driver}\" \"$cardinfo{mixername}\" \"$cardinfo{components}\" \"$attr{subsystem_vendor}\" \"$attr{subsystem_device}\"\n"
+ERROR="Found hardware: \"$cardinfo{driver}\" \"$cardinfo{mixername}\" \"$cardinfo{components}\" \"$attr{subsystem_vendor}\" \"$attr{subsystem_device}\"\n"
 ERROR="Hardware is initialized using a guess method\n"
 INCLUDE="default"
 EXIT="99"
-- 
1.7.6

From 7f6a55e203e2bb069c35006b605e1a19cfcd88cb Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Thu, 2 Sep 2010 15:36:56 +0200
Subject: [PATCH] alsactl init: use "generic method" instead "guess method"

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 alsactl/init/00main |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/alsactl/init/00main b/alsactl/init/00main
index fb7f02c..660df38 100644
--- a/alsactl/init/00main
+++ b/alsactl/init/00main
@@ -38,7 +38,7 @@ LABEL="init_end"
 ACCESS=="postinit", INCLUDE="postinit"
 RESULT=="true", GOTO="00_mainend"
 ERROR="Found hardware: \"$cardinfo{driver}\" \"$cardinfo{mixername}\" \"$cardinfo{components}\" \"$attr{subsystem_vendor}\" \"$attr{subsystem_device}\"\n"
-ERROR="Hardware is initialized using a guess method\n"
+ERROR="Hardware is initialized using a generic method\n"
 INCLUDE="default"
 EXIT="99"
 
-- 
1.7.6

From 0fea2452cb8bca5b5d28daedeb31df7a21284e7d Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Thu, 2 Sep 2010 15:48:43 +0200
Subject: [PATCH] alsactl: Change handling of inactive controls

The inactive controls are stored, but they are not restored
when they are marked inactive in the state file or in the
driver.

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 alsactl/state.c |   13 +++++++------
 1 files changed, 7 insertions(+), 6 deletions(-)

diff --git a/alsactl/state.c b/alsactl/state.c
index 7eb107f..7422deb 100644
--- a/alsactl/state.c
+++ b/alsactl/state.c
@@ -251,8 +251,7 @@ static int get_control(snd_ctl_t *handle, snd_ctl_elem_id_t *id, snd_config_t *t
 		return err;
 	}
 
-	if (snd_ctl_elem_info_is_inactive(info) ||
-				!snd_ctl_elem_info_is_readable(info))
+	if (!snd_ctl_elem_info_is_readable(info))
 		return 0;
 	snd_ctl_elem_value_set_id(ctl, id);
 	err = snd_ctl_elem_read(handle, ctl);
@@ -778,7 +777,7 @@ static int config_integer64(snd_config_t *n, long long *val, int doit)
 	return err;
 }
 
-static int is_user_control(snd_config_t *conf)
+static int check_comment_access(snd_config_t *conf, const char *str)
 {
 	snd_config_iterator_t i, next;
 
@@ -790,7 +789,7 @@ static int is_user_control(snd_config_t *conf)
 		if (strcmp(id, "access") == 0) {
 			if (snd_config_get_string(n, &s) < 0)
 				return 0;
-			if (strstr(s, "user"))
+			if (strstr(s, str))
 				return 1;
 		}
 	}
@@ -1004,7 +1003,6 @@ static int check_comment_range(snd_ctl_t *handle, snd_config_t *conf,
 	long nmin, nmax;
 	long odbmin, odbmax;
 	long ndbmin, ndbmax;
-	long db;
 	snd_ctl_elem_id_t *id;
 
 	if (snd_config_search(conf, "range", &n) < 0)
@@ -1256,7 +1254,7 @@ static int set_control(snd_ctl_t *handle, snd_config_t *control,
 		snd_ctl_elem_info_set_name(info, name);
 		snd_ctl_elem_info_set_index(info, index);
 		err = snd_ctl_elem_info(handle, info);
-		if (err < 0 && comment && is_user_control(comment)) {
+		if (err < 0 && comment && check_comment_access(comment, "user")) {
 			err = add_user_control(handle, info, comment);
 			if (err < 0) {
 				cerror(doit, "failed to add user control #%d (%s)",
@@ -1305,6 +1303,9 @@ static int set_control(snd_ctl_t *handle, snd_config_t *control,
 				return -EINVAL;
 			}
 		}
+		/* inactive controls are not restored */
+		if (comment && check_comment_access(comment, "inactive"))
+			return 0;
 	}
 
 	if (snd_ctl_elem_info_is_inactive(info) ||
-- 
1.7.6

From 52bd2f8acedaacce32ca8e89cb1f21683658648e Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Tue, 7 Sep 2010 17:07:12 +0200
Subject: [PATCH] alsactl init: Handle "Capture Source" and "Mic Boost" in the
 default script

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 alsactl/init/default |    6 ++++++
 1 files changed, 6 insertions(+), 0 deletions(-)

diff --git a/alsactl/init/default b/alsactl/init/default
index 35acfc3..9fd7972 100644
--- a/alsactl/init/default
+++ b/alsactl/init/default
@@ -185,6 +185,11 @@ CTL{name}="Capture Volume",CTL{do_search}=="1", \
 CTL{name}="Capture Switch",CTL{do_search}=="1", \
   CTL{values}="on"
 
+CTL{name}="Capture Source",PROGRAM!="__ctl_search", GOTO=""
+CTL{enums}=="*|Internal Mic|*",CTL{values}="Internal Mic", GOTO=""
+CTL{enums}=="*|Mic|*",CTL{values}="Mic"
+LABEL=""
+
 CTL{name}="Input Source",PROGRAM!="__ctl_search", GOTO=""
 CTL{enums}=="*|Internal Mic|*",CTL{values}="Internal Mic", GOTO=""
 CTL{enums}=="*|Mic|*",CTL{values}="Mic"
@@ -195,4 +200,5 @@ CTL{enums}=="*|Digital Mic 1|*",CTL{values}="Digital Mic 1", GOTO=""
 CTL{enums}=="*|Mic|*",CTL{values}="Mic"
 LABEL=""
 
+CTL{name}="Mic Boost",CTL{do_search}=="1", CTL{values}="on"
 CTL{name}="Internal Mic Boost",CTL{do_search}=="1", CTL{values}="on"
-- 
1.7.6

From ef919a4724169f4c0dc14168dec32c168b2471e4 Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Tue, 7 Sep 2010 17:33:14 +0200
Subject: [PATCH] alsactl init: Initialize also "Master Front Playback Volume"
 & "Switch"

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 alsactl/init/default |    7 +++++++
 1 files changed, 7 insertions(+), 0 deletions(-)

diff --git a/alsactl/init/default b/alsactl/init/default
index 9fd7972..7f8ec4c 100644
--- a/alsactl/init/default
+++ b/alsactl/init/default
@@ -30,6 +30,13 @@ CTL{name}="Master Playback Switch",CTL{do_search}=="1", \
   CTL{values}="on"
 
 CTL{reset}="mixer"
+CTL{name}="Master Front Playback Volume",CTL{do_search}=="1", \
+  ENV{has_pmaster_vol}:="true", \
+  CTL{write}!="$env{pvolume}",CTL{values}="$env{ppercent}"
+CTL{name}="Master Front Playback Switch",CTL{do_search}=="1", \
+  CTL{values}="on"
+
+CTL{reset}="mixer"
 CTL{name}="Master Digital Playback Volume",CTL{do_search}=="1", \
   CTL{write}!="$env{pvolume}",CTL{values}="$env{ppercent}"
 CTL{name}="Master Digital Playback Switch",CTL{do_search}=="1", \
-- 
1.7.6

From 87c58b59b5c443fe3244bd06417c451581d1f635 Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Tue, 5 Oct 2010 10:02:45 +0200
Subject: [PATCH] amixer: fix parsing of control ID name

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 amixer/amixer.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/amixer/amixer.c b/amixer/amixer.c
index c9ea572..a177288 100644
--- a/amixer/amixer.c
+++ b/amixer/amixer.c
@@ -1120,8 +1120,8 @@ static int parse_control_id(const char *str, snd_ctl_elem_id_t *id)
 					}
 					str++;
 				}
-				*ptr = '\0';
 			}
+			*ptr = '\0';
 			snd_ctl_elem_id_set_name(id, buf);
 		} else if (!strncasecmp(str, "index=", 6)) {
 			str += 6;
-- 
1.7.6

From b67d215d20bcf546617de962dec60cc29b238e4e Mon Sep 17 00:00:00 2001
From: David Henningsson <david.henningsson@canonical.com>
Date: Fri, 15 Oct 2010 12:30:44 +0200
Subject: [PATCH] speaker-test: Don't retry after fatal errors

Fixup commit 9b1a2566: Remove error loop

Signed-off-by: David Henningsson <david.henningsson@canonical.com>
Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 speaker-test/speaker-test.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/speaker-test/speaker-test.c b/speaker-test/speaker-test.c
index 458a8d7..3029110 100644
--- a/speaker-test/speaker-test.c
+++ b/speaker-test/speaker-test.c
@@ -993,9 +993,9 @@ int main(int argc, char *argv[]) {
 
   }
 
-  while ((err = snd_pcm_open(&handle, device, SND_PCM_STREAM_PLAYBACK, 0)) < 0) {
+  if ((err = snd_pcm_open(&handle, device, SND_PCM_STREAM_PLAYBACK, 0)) < 0) {
     printf(_("Playback open error: %d,%s\n"), err,snd_strerror(err));
-    sleep(1);
+    exit(EXIT_FAILURE);
   }
 
   if ((err = set_hwparams(handle, hwparams, SND_PCM_ACCESS_RW_INTERLEAVED)) < 0) {
-- 
1.7.6

From f2e9e9a5b017a3834941256da52e1d608f9c4c7b Mon Sep 17 00:00:00 2001
From: Clemens Ladisch <clemens@ladisch.de>
Date: Wed, 10 Nov 2010 10:14:53 +0100
Subject: [PATCH] alsamixer: remove obsolete e-mail

Tim Janik's e-mail address is no longer valid.

Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
---
 alsamixer/cli.c            |    2 +-
 alsamixer/colors.c         |    2 +-
 alsamixer/mixer_controls.c |    2 +-
 alsamixer/mixer_widget.c   |    4 ++--
 alsamixer/textbox.c        |    2 +-
 5 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/alsamixer/cli.c b/alsamixer/cli.c
index ab6255f..3898196 100644
--- a/alsamixer/cli.c
+++ b/alsamixer/cli.c
@@ -1,6 +1,6 @@
 /*
  * alsamixer - curses mixer for the ALSA project
- * Copyright (c) 1998,1999 Tim Janik <timj@gtk.org>
+ * Copyright (c) 1998,1999 Tim Janik
  *                         Jaroslav Kysela <perex@perex.cz>
  * Copyright (c) 2009      Clemens Ladisch <clemens@ladisch.de>
  *
diff --git a/alsamixer/colors.c b/alsamixer/colors.c
index fcceb16..b4b98e5 100644
--- a/alsamixer/colors.c
+++ b/alsamixer/colors.c
@@ -1,6 +1,6 @@
 /*
  * colors.c - color and attribute definitions
- * Copyright (c) 1998,1999 Tim Janik <timj@gtk.org>
+ * Copyright (c) 1998,1999 Tim Janik
  *                         Jaroslav Kysela <perex@perex.cz>
  * Copyright (c) 2009      Clemens Ladisch <clemens@ladisch.de>
  *
diff --git a/alsamixer/mixer_controls.c b/alsamixer/mixer_controls.c
index 796df7b..cc98b64 100644
--- a/alsamixer/mixer_controls.c
+++ b/alsamixer/mixer_controls.c
@@ -1,6 +1,6 @@
 /*
  * mixer_controls.c - handles mixer controls and mapping from selems
- * Copyright (c) 1998,1999 Tim Janik <timj@gtk.org>
+ * Copyright (c) 1998,1999 Tim Janik
  *                         Jaroslav Kysela <perex@perex.cz>
  * Copyright (c) 2009      Clemens Ladisch <clemens@ladisch.de>
  *
diff --git a/alsamixer/mixer_widget.c b/alsamixer/mixer_widget.c
index 796ea1d..c8ca156 100644
--- a/alsamixer/mixer_widget.c
+++ b/alsamixer/mixer_widget.c
@@ -1,6 +1,6 @@
 /*
  * mixer_widget.c - mixer widget and keys handling
- * Copyright (c) 1998,1999 Tim Janik <timj@gtk.org>
+ * Copyright (c) 1998,1999 Tim Janik
  *                         Jaroslav Kysela <perex@perex.cz>
  * Copyright (c) 2009      Clemens Ladisch <clemens@ladisch.de>
  *
@@ -211,7 +211,7 @@ static void show_help(void)
 		_("; '        Toggle left/right capture"),
 		"",
 		_("Authors:"),
-		_("  Tim Janik <timj@gtk.org>"),
+		_("  Tim Janik"),
 		_("  Jaroslav Kysela <perex@perex.cz>"),
 		_("  Clemens Ladisch <clemens@ladisch.de>"),
 	};
diff --git a/alsamixer/textbox.c b/alsamixer/textbox.c
index d743a14..a979d3c 100644
--- a/alsamixer/textbox.c
+++ b/alsamixer/textbox.c
@@ -1,6 +1,6 @@
 /*
  * textbox.c - show a text box for messages, files or help
- * Copyright (c) 1998,1999 Tim Janik <timj@gtk.org>
+ * Copyright (c) 1998,1999 Tim Janik
  *                         Jaroslav Kysela <perex@perex.cz>
  * Copyright (c) 2009      Clemens Ladisch <clemens@ladisch.de>
  *
-- 
1.7.6

From e57f619c82e2fec20c20c30f56d3fa4db22a8353 Mon Sep 17 00:00:00 2001
From: Clemens Ladisch <clemens@ladisch.de>
Date: Mon, 6 Dec 2010 14:04:39 +0100
Subject: [PATCH] alsamixer: remove obsolete e-mail

Remove the no-longer-valid e-mail address also from the man page.

Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
---
 alsamixer/alsamixer.1 |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/alsamixer/alsamixer.1 b/alsamixer/alsamixer.1
index ba05aca..cd88404 100644
--- a/alsamixer/alsamixer.1
+++ b/alsamixer/alsamixer.1
@@ -171,7 +171,7 @@ fault. Plain old \fBxterm\fP seems to be fine.
 
 .SH AUTHOR
 .B alsamixer
-has been written by Tim Janik <timj@gtk.org> and
+has been written by Tim Janik and
 been further improved by Jaroslav Kysela <perex@perex.cz>
 and Clemens Ladisch <clemens@ladisch.de>.
 
-- 
1.7.6

From 70a01748d594ef57a1962e4cb012927faf6d852f Mon Sep 17 00:00:00 2001
From: Clemens Ladisch <clemens@ladisch.de>
Date: Mon, 6 Dec 2010 14:05:10 +0100
Subject: [PATCH] alsamixer: increase step size for big control value ranges

For controls with a big range, stepping through all values can become
tedious and make it impossible to adjust the volume easily.  Therefore,
ensure that all steps are big enough so that the full range has at most
one hundred steps.

Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
---
 alsamixer/mixer_widget.c |    4 +++-
 1 files changed, 3 insertions(+), 1 deletions(-)

diff --git a/alsamixer/mixer_widget.c b/alsamixer/mixer_widget.c
index c8ca156..adb4568 100644
--- a/alsamixer/mixer_widget.c
+++ b/alsamixer/mixer_widget.c
@@ -318,7 +318,7 @@ static void change_volume_to_percent(struct control *control, int value, unsigne
 		set_func(control->elem, control->volume_channels[1], min + (max - min) * value / 100);
 }
 
-static void change_volume_relative(struct control *control, int delta, unsigned int channels)
+static void change_volume_relative(struct control *control, long delta, unsigned int channels)
 {
 	int (*get_range_func)(snd_mixer_elem_t *, long *, long *);
 	int (*get_func)(snd_mixer_elem_t *, snd_mixer_selem_channel_id_t, long *);
@@ -352,6 +352,8 @@ static void change_volume_relative(struct control *control, int delta, unsigned
 		if (err < 0)
 			return;
 	}
+	if (max - min > 100)
+		delta = (delta * (max - min) + (delta > 0 ? 99 : -99)) / 100;
 	if (channels & LEFT) {
 		value = left + delta;
 		if (value < min)
-- 
1.7.6

From 34bb514b5fd1d6f91ba9a7b3a70b0ea0c6014250 Mon Sep 17 00:00:00 2001
From: Clemens Ladisch <clemens@ladisch.de>
Date: Mon, 6 Dec 2010 14:07:48 +0100
Subject: [PATCH] alsamixer: use cubic scale for volume bars

Instead of mapping the raw volume values linearly to the screen, use
a mapping where the bar height is proportional to the audible volume,
i.e., where the amplitude is the cube of the bar height.

Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
---
 alsamixer/Makefile.am      |    1 +
 alsamixer/mixer_display.c  |   53 ++++---------
 alsamixer/mixer_widget.c   |  120 +++++++++++-------------------
 alsamixer/volume_mapping.c |  180 ++++++++++++++++++++++++++++++++++++++++++++
 alsamixer/volume_mapping.h |   19 +++++
 5 files changed, 260 insertions(+), 113 deletions(-)
 create mode 100644 alsamixer/volume_mapping.c
 create mode 100644 alsamixer/volume_mapping.h

diff --git a/alsamixer/Makefile.am b/alsamixer/Makefile.am
index 1de47c6..8a82323 100644
--- a/alsamixer/Makefile.am
+++ b/alsamixer/Makefile.am
@@ -15,6 +15,7 @@ alsamixer_SOURCES = card_select.c card_select.h \
 		proc_files.c proc_files.h \
 		textbox.c textbox.h \
 		utils.c utils.h \
+		volume_mapping.c volume_mapping.h \
 		widget.c widget.h
 man_MANS = alsamixer.1
 EXTRA_DIST = alsamixer.1
diff --git a/alsamixer/mixer_display.c b/alsamixer/mixer_display.c
index 20d6d6a..51a1546 100644
--- a/alsamixer/mixer_display.c
+++ b/alsamixer/mixer_display.c
@@ -17,10 +17,12 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#define _C99_SOURCE /* lrint() */
 #include "aconfig.h"
 #include <stdlib.h>
 #include <string.h>
 #include <strings.h>
+#include <math.h>
 #include CURSESINC
 #include <alsa/asoundlib.h>
 #include "gettext_curses.h"
@@ -28,6 +30,7 @@
 #include "mem.h"
 #include "colors.h"
 #include "widget.h"
+#include "volume_mapping.h"
 #include "mixer_widget.h"
 #include "mixer_controls.h"
 #include "mixer_display.h"
@@ -390,24 +393,14 @@ static void display_string_centered_in_control(int y, int col, const char *s, in
 	display_string_in_field(y, x, s, width, ALIGN_CENTER);
 }
 
-static long clamp(long value, long min, long max)
-{
-	if (value < min)
-		return min;
-	if (value > max)
-		return max;
-	return value;
-}
-
 static void display_control(unsigned int control_index)
 {
 	struct control *control;
 	int col;
 	int i, c;
 	int left, frame_left;
-	int bar_height, value;
-	long volumes[2];
-	long min, max;
+	int bar_height;
+	double volumes[2];
 	int switches[2];
 	unsigned int index;
 	const char *s;
@@ -452,35 +445,22 @@ static void display_control(unsigned int control_index)
 		waddch(mixer_widget.window, ACS_LRCORNER);
 	}
 	if (control->flags & (TYPE_PVOLUME | TYPE_CVOLUME)) {
-		int (*get_vol_func)(snd_mixer_elem_t *, snd_mixer_selem_channel_id_t, long *);
+		double (*get_vol_func)(snd_mixer_elem_t *, snd_mixer_selem_channel_id_t);
 
 		if (control->flags & TYPE_PVOLUME)
-			get_vol_func = snd_mixer_selem_get_playback_volume;
+			get_vol_func = get_normalized_playback_volume;
 		else
-			get_vol_func = snd_mixer_selem_get_capture_volume;
-		err = get_vol_func(control->elem, control->volume_channels[0], &volumes[0]);
-		if (err >= 0 && (control->flags & HAS_VOLUME_1))
-			err = get_vol_func(control->elem, control->volume_channels[1], &volumes[1]);
+			get_vol_func = get_normalized_capture_volume;
+		volumes[0] = get_vol_func(control->elem, control->volume_channels[0]);
+		if (control->flags & HAS_VOLUME_1)
+			volumes[1] = get_vol_func(control->elem, control->volume_channels[1]);
 		else
 			volumes[1] = volumes[0];
-		if (err < 0)
-			return;
-		if (control->flags & TYPE_PVOLUME)
-			err = snd_mixer_selem_get_playback_volume_range(control->elem, &min, &max);
-		else
-			err = snd_mixer_selem_get_capture_volume_range(control->elem, &min, &max);
-		if (err < 0)
-			return;
-		if (min >= max)
-			max = min + 1;
-		volumes[0] = clamp(volumes[0], min, max);
-		volumes[1] = clamp(volumes[1], min, max);
 
 		if (control->flags & IS_ACTIVE)
 			wattrset(mixer_widget.window, 0);
 		for (c = 0; c < 2; c++) {
-			bar_height = ((volumes[c] - min) * volume_height +
-				      max - min - 1) / (max - min);
+			bar_height = lrint(volumes[c] * volume_height);
 			for (i = 0; i < volume_height; ++i) {
 				chtype ch;
 				if (i + 1 > bar_height)
@@ -505,19 +485,18 @@ static void display_control(unsigned int control_index)
 		}
 		if (control->flags & IS_ACTIVE)
 			wattrset(mixer_widget.window, attr_mixer_active);
-		value = ((volumes[0] - min) * 100 + (max - min) / 2) / (max - min);
 		if (!(control->flags & HAS_VOLUME_1)) {
-			sprintf(buf, "%d", value);
+			sprintf(buf, "%d", lrint(volumes[0] * 100));
 			display_string_in_field(values_y, frame_left - 2, buf, 8, ALIGN_CENTER);
 		} else {
-			mvwprintw(mixer_widget.window, values_y, frame_left - 2, "%3d", value);
+			mvwprintw(mixer_widget.window, values_y, frame_left - 2,
+				  "%3d", lrint(volumes[0] * 100));
 			if (control->flags & IS_ACTIVE)
 				wattrset(mixer_widget.window, attr_ctl_frame);
 			waddstr(mixer_widget.window, "<>");
 			if (control->flags & IS_ACTIVE)
 				wattrset(mixer_widget.window, attr_mixer_active);
-			value = ((volumes[1] - min) * 100 + (max - min) / 2) / (max - min);
-			wprintw(mixer_widget.window, "%-3d", value);
+			wprintw(mixer_widget.window, "%-3d", lrint(volumes[1] * 100));
 		}
 	}
 
diff --git a/alsamixer/mixer_widget.c b/alsamixer/mixer_widget.c
index adb4568..fb352d3 100644
--- a/alsamixer/mixer_widget.c
+++ b/alsamixer/mixer_widget.c
@@ -33,6 +33,7 @@
 #include "textbox.h"
 #include "proc_files.h"
 #include "card_select.h"
+#include "volume_mapping.h"
 #include "mixer_controls.h"
 #include "mixer_display.h"
 #include "mixer_widget.h"
@@ -295,82 +296,57 @@ static void change_enum_relative(struct control *control, int delta)
 
 static void change_volume_to_percent(struct control *control, int value, unsigned int channels)
 {
-	int (*get_range_func)(snd_mixer_elem_t *, long *, long *);
-	int (*set_func)(snd_mixer_elem_t *, snd_mixer_selem_channel_id_t, long);
-	long min, max;
-	int err;
+	int (*set_func)(snd_mixer_elem_t *, snd_mixer_selem_channel_id_t, double, int);
 
 	if (!(control->flags & HAS_VOLUME_1))
 		channels = LEFT;
-	if (control->flags & TYPE_PVOLUME) {
-		get_range_func = snd_mixer_selem_get_playback_volume_range;
-		set_func = snd_mixer_selem_set_playback_volume;
-	} else {
-		get_range_func = snd_mixer_selem_get_capture_volume_range;
-		set_func = snd_mixer_selem_set_capture_volume;
-	}
-	err = get_range_func(control->elem, &min, &max);
-	if (err < 0)
-		return;
+	if (control->flags & TYPE_PVOLUME)
+		set_func = set_normalized_playback_volume;
+	else
+		set_func = set_normalized_capture_volume;
 	if (channels & LEFT)
-		set_func(control->elem, control->volume_channels[0], min + (max - min) * value / 100);
+		set_func(control->elem, control->volume_channels[0], value / 100.0, 0);
 	if (channels & RIGHT)
-		set_func(control->elem, control->volume_channels[1], min + (max - min) * value / 100);
+		set_func(control->elem, control->volume_channels[1], value / 100.0, 0);
 }
 
-static void change_volume_relative(struct control *control, long delta, unsigned int channels)
+static double clamp_volume(double v)
 {
-	int (*get_range_func)(snd_mixer_elem_t *, long *, long *);
-	int (*get_func)(snd_mixer_elem_t *, snd_mixer_selem_channel_id_t, long *);
-	int (*set_func)(snd_mixer_elem_t *, snd_mixer_selem_channel_id_t, long);
-	long min, max;
-	long left, right;
-	long value;
-	int err;
+	if (v < 0)
+		return 0;
+	if (v > 1)
+		return 1;
+	return v;
+}
+
+static void change_volume_relative(struct control *control, int delta, unsigned int channels)
+{
+	double (*get_func)(snd_mixer_elem_t *, snd_mixer_selem_channel_id_t);
+	int (*set_func)(snd_mixer_elem_t *, snd_mixer_selem_channel_id_t, double, int);
+	double left, right;
+	int dir;
 
 	if (!(control->flags & HAS_VOLUME_1))
 		channels = LEFT;
 	if (control->flags & TYPE_PVOLUME) {
-		get_range_func = snd_mixer_selem_get_playback_volume_range;
-		get_func = snd_mixer_selem_get_playback_volume;
-		set_func = snd_mixer_selem_set_playback_volume;
+		get_func = get_normalized_playback_volume;
+		set_func = set_normalized_playback_volume;
 	} else {
-		get_range_func = snd_mixer_selem_get_capture_volume_range;
-		get_func = snd_mixer_selem_get_capture_volume;
-		set_func = snd_mixer_selem_set_capture_volume;
+		get_func = get_normalized_capture_volume;
+		set_func = set_normalized_capture_volume;
 	}
-	err = get_range_func(control->elem, &min, &max);
-	if (err < 0)
-		return;
-	if (channels & LEFT) {
-		err = get_func(control->elem, control->volume_channels[0], &left);
-		if (err < 0)
-			return;
-	}
-	if (channels & RIGHT) {
-		err = get_func(control->elem, control->volume_channels[1], &right);
-		if (err < 0)
-			return;
-	}
-	if (max - min > 100)
-		delta = (delta * (max - min) + (delta > 0 ? 99 : -99)) / 100;
+	if (channels & LEFT)
+		left = get_func(control->elem, control->volume_channels[0]);
+	if (channels & RIGHT)
+		right = get_func(control->elem, control->volume_channels[1]);
+	dir = delta > 0 ? 1 : -1;
 	if (channels & LEFT) {
-		value = left + delta;
-		if (value < min)
-			value = min;
-		else if (value > max)
-			value = max;
-		if (value != left)
-			set_func(control->elem, control->volume_channels[0], value);
+		left = clamp_volume(left + delta / 100.0);
+		set_func(control->elem, control->volume_channels[0], left, dir);
 	}
 	if (channels & RIGHT) {
-		value = right + delta;
-		if (value < min)
-			value = min;
-		else if (value > max)
-			value = max;
-		if (value != right)
-			set_func(control->elem, control->volume_channels[1], value);
+		right = clamp_volume(right + delta / 100.0);
+		set_func(control->elem, control->volume_channels[1], right, dir);
 	}
 }
 
@@ -460,34 +436,26 @@ static void toggle_capture(unsigned int channels)
 static void balance_volumes(void)
 {
 	struct control *control;
-	long left, right;
+	double left, right;
 	int err;
 
 	control = get_focus_control(TYPE_PVOLUME | TYPE_CVOLUME);
 	if (!control || !(control->flags & HAS_VOLUME_1))
 		return;
 	if (control->flags & TYPE_PVOLUME) {
-		err = snd_mixer_selem_get_playback_volume(control->elem, control->volume_channels[0], &left);
-		if (err < 0)
-			return;
-		err = snd_mixer_selem_get_playback_volume(control->elem, control->volume_channels[1], &right);
-		if (err < 0)
-			return;
+		left = get_normalized_playback_volume(control->elem, control->volume_channels[0]);
+		right = get_normalized_playback_volume(control->elem, control->volume_channels[1]);
 	} else {
-		err = snd_mixer_selem_get_capture_volume(control->elem, control->volume_channels[0], &left);
-		if (err < 0)
-			return;
-		err = snd_mixer_selem_get_capture_volume(control->elem, control->volume_channels[1], &right);
-		if (err < 0)
-			return;
+		left = get_normalized_capture_volume(control->elem, control->volume_channels[0]);
+		right = get_normalized_capture_volume(control->elem, control->volume_channels[1]);
 	}
 	left = (left + right) / 2;
 	if (control->flags & TYPE_PVOLUME) {
-		snd_mixer_selem_set_playback_volume(control->elem, control->volume_channels[0], left);
-		snd_mixer_selem_set_playback_volume(control->elem, control->volume_channels[1], left);
+		set_normalized_playback_volume(control->elem, control->volume_channels[0], left, 0);
+		set_normalized_playback_volume(control->elem, control->volume_channels[1], left, 0);
 	} else {
-		snd_mixer_selem_set_capture_volume(control->elem, control->volume_channels[0], left);
-		snd_mixer_selem_set_capture_volume(control->elem, control->volume_channels[1], left);
+		set_normalized_capture_volume(control->elem, control->volume_channels[0], left, 0);
+		set_normalized_capture_volume(control->elem, control->volume_channels[1], left, 0);
 	}
 	display_controls();
 }
diff --git a/alsamixer/volume_mapping.c b/alsamixer/volume_mapping.c
new file mode 100644
index 0000000..9cacad8
--- /dev/null
+++ b/alsamixer/volume_mapping.c
@@ -0,0 +1,180 @@
+/*
+ * Copyright (c) 2010 Clemens Ladisch <clemens@ladisch.de>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/*
+ * The functions in this file map the value ranges of ALSA mixer controls onto
+ * the interval 0..1.
+ *
+ * The mapping is designed so that the position in the interval is proportional
+ * to the volume as a human ear would perceive it (i.e., the position is the
+ * cubic root of the linear sample multiplication factor).  For controls with
+ * a small range (24 dB or less), the mapping is linear in the dB values so
+ * that each step has the same size visually.  Only for controls without dB
+ * information, a linear mapping of the hardware volume register values is used
+ * (this is the same algorithm as used in the old alsamixer).
+ *
+ * When setting the volume, 'dir' is the rounding direction:
+ * -1/0/1 = down/nearest/up.
+ */
+
+#define _ISOC99_SOURCE /* lrint() */
+#define _GNU_SOURCE /* exp10() */
+#include "aconfig.h"
+#include <math.h>
+#include <stdbool.h>
+#include "volume_mapping.h"
+
+#define MAX_LINEAR_DB_SCALE	24
+
+static inline bool use_linear_dB_scale(long dBmin, long dBmax)
+{
+	return dBmax - dBmin <= MAX_LINEAR_DB_SCALE * 100;
+}
+
+static long lrint_dir(double x, int dir)
+{
+	if (dir > 0)
+		return lrint(ceil(x));
+	else if (dir < 0)
+		return lrint(floor(x));
+	else
+		return lrint(x);
+}
+
+enum ctl_dir { PLAYBACK, CAPTURE };
+
+static int (* const get_dB_range[2])(snd_mixer_elem_t *, long *, long *) = {
+	snd_mixer_selem_get_playback_dB_range,
+	snd_mixer_selem_get_capture_dB_range,
+};
+static int (* const get_raw_range[2])(snd_mixer_elem_t *, long *, long *) = {
+	snd_mixer_selem_get_playback_volume_range,
+	snd_mixer_selem_get_capture_volume_range,
+};
+static int (* const get_dB[2])(snd_mixer_elem_t *, snd_mixer_selem_channel_id_t, long *) = {
+	snd_mixer_selem_get_playback_dB,
+	snd_mixer_selem_get_capture_dB,
+};
+static int (* const get_raw[2])(snd_mixer_elem_t *, snd_mixer_selem_channel_id_t, long *) = {
+	snd_mixer_selem_get_playback_volume,
+	snd_mixer_selem_get_capture_volume,
+};
+static int (* const set_dB[2])(snd_mixer_elem_t *, snd_mixer_selem_channel_id_t, long, int) = {
+	snd_mixer_selem_set_playback_dB,
+	snd_mixer_selem_set_capture_dB,
+};
+static int (* const set_raw[2])(snd_mixer_elem_t *, snd_mixer_selem_channel_id_t, long) = {
+	snd_mixer_selem_set_playback_volume,
+	snd_mixer_selem_set_capture_volume,
+};
+
+static double get_normalized_volume(snd_mixer_elem_t *elem,
+				    snd_mixer_selem_channel_id_t channel,
+				    enum ctl_dir ctl_dir)
+{
+	long min, max, value;
+	double normalized, min_norm;
+	int err;
+
+	err = get_dB_range[ctl_dir](elem, &min, &max);
+	if (err < 0 || min >= max) {
+		err = get_raw_range[ctl_dir](elem, &min, &max);
+		if (err < 0 || min == max)
+			return 0;
+
+		err = get_raw[ctl_dir](elem, channel, &value);
+		if (err < 0)
+			return 0;
+
+		return (value - min) / (double)(max - min);
+	}
+
+	err = get_dB[ctl_dir](elem, channel, &value);
+	if (err < 0)
+		return 0;
+
+	if (use_linear_dB_scale(min, max))
+		return (value - min) / (double)(max - min);
+
+	normalized = exp10((value - max) / 6000.0);
+	if (min != SND_CTL_TLV_DB_GAIN_MUTE) {
+		min_norm = exp10((min - max) / 6000.0);
+		normalized = (normalized - min_norm) / (1 - min_norm);
+	}
+
+	return normalized;
+}
+
+static int set_normalized_volume(snd_mixer_elem_t *elem,
+				 snd_mixer_selem_channel_id_t channel,
+				 double volume,
+				 int dir,
+				 enum ctl_dir ctl_dir)
+{
+	long min, max, value;
+	double min_norm;
+	int err;
+
+	err = get_dB_range[ctl_dir](elem, &min, &max);
+	if (err < 0 || min >= max) {
+		err = get_raw_range[ctl_dir](elem, &min, &max);
+		if (err < 0)
+			return err;
+
+		value = lrint_dir(volume * (max - min), dir) + min;
+		return set_raw[ctl_dir](elem, channel, value);
+	}
+
+	if (use_linear_dB_scale(min, max)) {
+		value = lrint_dir(volume * (max - min), dir) + min;
+		return set_dB[ctl_dir](elem, channel, value, dir);
+	}
+
+	if (min != SND_CTL_TLV_DB_GAIN_MUTE) {
+		min_norm = exp10((min - max) / 6000.0);
+		volume = volume * (1 - min_norm) + min_norm;
+	}
+	value = lrint_dir(6000.0 * log10(volume), dir) + max;
+	return set_dB[ctl_dir](elem, channel, value, dir);
+}
+
+double get_normalized_playback_volume(snd_mixer_elem_t *elem,
+				      snd_mixer_selem_channel_id_t channel)
+{
+	return get_normalized_volume(elem, channel, PLAYBACK);
+}
+
+double get_normalized_capture_volume(snd_mixer_elem_t *elem,
+				     snd_mixer_selem_channel_id_t channel)
+{
+	return get_normalized_volume(elem, channel, CAPTURE);
+}
+
+int set_normalized_playback_volume(snd_mixer_elem_t *elem,
+				   snd_mixer_selem_channel_id_t channel,
+				   double volume,
+				   int dir)
+{
+	return set_normalized_volume(elem, channel, volume, dir, PLAYBACK);
+}
+
+int set_normalized_capture_volume(snd_mixer_elem_t *elem,
+				  snd_mixer_selem_channel_id_t channel,
+				  double volume,
+				  int dir)
+{
+	return set_normalized_volume(elem, channel, volume, dir, CAPTURE);
+}
diff --git a/alsamixer/volume_mapping.h b/alsamixer/volume_mapping.h
new file mode 100644
index 0000000..d4251d6
--- /dev/null
+++ b/alsamixer/volume_mapping.h
@@ -0,0 +1,19 @@
+#ifndef VOLUME_MAPPING_H_INCLUDED
+#define VOLUME_MAPPING_H_INCLUDED
+
+#include <alsa/asoundlib.h>
+
+double get_normalized_playback_volume(snd_mixer_elem_t *elem,
+				      snd_mixer_selem_channel_id_t channel);
+double get_normalized_capture_volume(snd_mixer_elem_t *elem,
+				     snd_mixer_selem_channel_id_t channel);
+int set_normalized_playback_volume(snd_mixer_elem_t *elem,
+				   snd_mixer_selem_channel_id_t channel,
+				   double volume,
+				   int dir);
+int set_normalized_capture_volume(snd_mixer_elem_t *elem,
+				  snd_mixer_selem_channel_id_t channel,
+				  double volume,
+				  int dir);
+
+#endif
-- 
1.7.6

From 0bd306df6322571d158ce998e2d209240a7cd9ae Mon Sep 17 00:00:00 2001
From: "Christoph J. Thompson" <cjsthompson@gmail.com>
Date: Fri, 7 Jan 2011 13:46:58 +0100
Subject: [PATCH] Translate alsa-utils to French.

	modified:   po/LINGUAS
	new file:   po/fr.po

Signed-off-by: Christoph J. Thompson <cjsthompson@gmail.com>
Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 po/LINGUAS |    2 +-
 po/fr.po   | 1566 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 1567 insertions(+), 1 deletions(-)
 create mode 100644 po/fr.po

diff --git a/po/LINGUAS b/po/LINGUAS
index 081e105..2027386 100644
--- a/po/LINGUAS
+++ b/po/LINGUAS
@@ -1 +1 @@
-ja de
+de fr ja
diff --git a/po/fr.po b/po/fr.po
new file mode 100644
index 0000000..a6028a4
--- /dev/null
+++ b/po/fr.po
@@ -0,0 +1,1566 @@
+# French translation for alsa-utils
+# Copyright (C) 2011 The ALSA Team
+# This file is distributed under the same license as the alsa-utils package.
+# Christoph J. Thompson <cjsthompson@gmail.com>, 2011.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: alsa-utils 1.0.23\n"
+"Report-Msgid-Bugs-To: \n"
+"POT-Creation-Date: 2011-01-07 06:23+0100\n"
+"PO-Revision-Date: 2011-01-07 06:23+0100\n"
+"Last-Translator: Christoph J. Thompson <cjsthompson@gmail.com>\n"
+"Language-Team: French <fr@li.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#: ../alsamixer/card_select.c:126 ../alsamixer/device_name.c:126
+msgid "Sound Card"
+msgstr "Carte Son"
+
+#: ../alsamixer/card_select.c:181
+msgid "(default)"
+msgstr "(par défaut)"
+
+#: ../alsamixer/card_select.c:191
+msgid "cannot enumerate sound cards"
+msgstr "les cartes son n'ont pas pu être énumérées"
+
+#: ../alsamixer/card_select.c:215
+msgid "enter device name..."
+msgstr "entrez le nom du périphérique..."
+
+#: ../alsamixer/cli.c:40
+msgid "Usage: alsamixer [options]"
+msgstr "Utilisation: alsamixer [options]"
+
+#: ../alsamixer/cli.c:41
+msgid ""
+"Useful options:\n"
+"  -h, --help              this help\n"
+"  -c, --card=NUMBER       sound card number or id\n"
+"  -D, --device=NAME       mixer device name\n"
+"  -V, --view=MODE         starting view mode: playback/capture/all"
+msgstr ""
+"Options utiles:\n"
+"  -h, --help           cette aide\n"
+"  -c, --card=NUMÉRO    numéro ou identifiant de la carte son\n"
+"  -D, --device=NOM     nom du périphérique de mixage\n"
+"  -V, --view=MODE      mode de visualisation par défaut: lecture/capture/tous"
+
+#: ../alsamixer/cli.c:46
+msgid ""
+"Debugging options:\n"
+"  -g, --no-color          toggle using of colors\n"
+"  -a, --abstraction=NAME  mixer abstraction level: none/basic"
+msgstr ""
+"Options de débogage:\n"
+"  -g, --no-color          supprimer la couleur\n"
+"  -a, --abstraction=NOM   niveau d'abstraction du mixeur: aucun/basique"
+
+#: ../alsamixer/cli.c:77
+#, c-format
+msgid "invalid card index: %s\n"
+msgstr "index de carte invalide: %s\n"
+
+#: ../alsamixer/cli.c:103
+#, c-format
+msgid "unknown abstraction level: %s\n"
+msgstr "niveau d'abstraction inconnu: %s\n"
+
+#: ../alsamixer/cli.c:108
+#, c-format
+msgid "unknown option: %c\n"
+msgstr "option inconnue: %c\n"
+
+#: ../alsamixer/cli.c:110
+msgid "try `alsamixer --help' for more information\n"
+msgstr "essayez `alsamixer --help' pour plus d'information\n"
+
+#: ../alsamixer/device_name.c:177
+msgid "Device name:"
+msgstr "Nom du périphérique:"
+
+#: ../alsamixer/die.c:37
+#, c-format
+msgid "%s: %s\n"
+msgstr "%s: %s\n"
+
+#: ../alsamixer/mixer_display.c:95
+msgid "Card:"
+msgstr "Carte:"
+
+#: ../alsamixer/mixer_display.c:96
+msgid "Chip:"
+msgstr "Puce:"
+
+#: ../alsamixer/mixer_display.c:97
+msgid "View:"
+msgstr "Vue:"
+
+#: ../alsamixer/mixer_display.c:98
+msgid "Item:"
+msgstr "Contrôle:"
+
+#: ../alsamixer/mixer_display.c:101
+msgid "F1:  Help"
+msgstr "F1:  Aide"
+
+#: ../alsamixer/mixer_display.c:102
+msgid "F2:  System information"
+msgstr "F2:  Informations Système"
+
+#: ../alsamixer/mixer_display.c:103
+msgid "F6:  Select sound card"
+msgstr "F6:  Choisir la carte son"
+
+#: ../alsamixer/mixer_display.c:104
+msgid "Esc: Exit"
+msgstr "Esc: Quitter"
+
+#: ../alsamixer/mixer_display.c:171
+msgid "(unplugged)"
+msgstr "(non branché)"
+
+#: ../alsamixer/mixer_display.c:189
+msgid "Playback"
+msgstr "Lecture"
+
+#: ../alsamixer/mixer_display.c:190
+msgid "Capture"
+msgstr "Capture"
+
+#: ../alsamixer/mixer_display.c:191
+msgid "All"
+msgstr "Tout"
+
+#: ../alsamixer/mixer_display.c:231
+msgid "mute"
+msgstr "muet"
+
+#: ../alsamixer/mixer_display.c:272 ../alsamixer/mixer_display.c:282
+msgid "dB gain:"
+msgstr "gain dB:"
+
+#: ../alsamixer/mixer_display.c:282
+#, c-format
+msgid " [%s %s, %s]"
+msgstr " [%s %s, %s]"
+
+#: ../alsamixer/mixer_display.c:291 ../alsamixer/mixer_display.c:297
+#: ../alsamixer/mixer_display.c:303 ../alsamixer/mixer_display.c:309
+msgid "Off"
+msgstr "Fermé"
+
+#: ../alsamixer/mixer_display.c:297 ../alsamixer/mixer_display.c:309
+msgid "On"
+msgstr "Ouvert"
+
+#: ../alsamixer/mixer_display.c:360
+msgid "The sound device was unplugged."
+msgstr "Le périphérique a été débranché"
+
+#: ../alsamixer/mixer_display.c:361
+msgid "Press F6 to select another sound card."
+msgstr "Appuyez sur F6 pour choisir une autre carte son."
+
+#: ../alsamixer/mixer_display.c:376
+msgid "This sound device does not have any playback controls."
+msgstr "Ce périphérique n'a pas de commandes de lecture."
+
+#: ../alsamixer/mixer_display.c:378
+msgid "This sound device does not have any capture controls."
+msgstr "Ce périphérique n'a pas de commandes de capture."
+
+#: ../alsamixer/mixer_display.c:380
+msgid "This sound device does not have any controls."
+msgstr "Ce périphérique n'a pas de commandes."
+
+#. TRANSLATORS: playback on; one character
+#: ../alsamixer/mixer_display.c:537 ../alsamixer/mixer_display.c:542
+msgid "O"
+msgstr "O"
+
+#. TRANSLATORS: playback muted; one character
+#: ../alsamixer/mixer_display.c:539 ../alsamixer/mixer_display.c:543
+msgid "M"
+msgstr "M"
+
+#. TRANSLATORS: "left"; no more than two characters
+#: ../alsamixer/mixer_display.c:557
+msgid "L"
+msgstr "G"
+
+#. TRANSLATORS: "right"; no more than two characters
+#: ../alsamixer/mixer_display.c:561
+msgid "R"
+msgstr "D"
+
+#. TRANSLATORS: no more than eight characters
+#: ../alsamixer/mixer_display.c:563
+msgid "CAPTURE"
+msgstr "CAPTURE"
+
+#: ../alsamixer/mixer_display.c:613
+msgid "Front"
+msgstr "Avant"
+
+#: ../alsamixer/mixer_display.c:616
+msgid "Rear"
+msgstr "Arrière"
+
+#. 4
+#: ../alsamixer/mixer_display.c:619 ../speaker-test/speaker-test.c:107
+msgid "Center"
+msgstr "Centre"
+
+#: ../alsamixer/mixer_display.c:622
+msgid "Woofer"
+msgstr "Basses"
+
+#: ../alsamixer/mixer_display.c:625
+msgid "Side"
+msgstr "Côté"
+
+#: ../alsamixer/mixer_widget.c:83 ../alsamixer/mixer_widget.c:88
+msgid "cannot open mixer"
+msgstr "le mixeur ne peut pas être ouvert"
+
+#: ../alsamixer/mixer_widget.c:94 ../alsamixer/mixer_widget.c:171
+msgid "cannot load mixer controls"
+msgstr "les commandes de mixage ne peuvent pas être chargés"
+
+#: ../alsamixer/mixer_widget.c:161
+#, c-format
+msgid "Cannot open mixer device '%s'."
+msgstr "Le périphérique de mixage '%s' ne peut pas être ouvert."
+
+#: ../alsamixer/mixer_widget.c:182
+msgid "Esc     Exit"
+msgstr "Esc     Quitter"
+
+#: ../alsamixer/mixer_widget.c:183
+msgid "F1 ? H  Help"
+msgstr "F1 ? H  Aide"
+
+#: ../alsamixer/mixer_widget.c:184
+msgid "F2 /    System information"
+msgstr "F2 /    Informations système"
+
+#: ../alsamixer/mixer_widget.c:185
+msgid "F3      Show playback controls"
+msgstr "F3      Afficher les commandes de lecture"
+
+#: ../alsamixer/mixer_widget.c:186
+msgid "F4      Show capture controls"
+msgstr "F4      Afficher les commandes de capture"
+
+#: ../alsamixer/mixer_widget.c:187
+msgid "F5      Show all controls"
+msgstr "F5      Afficher toutes les commandes"
+
+#: ../alsamixer/mixer_widget.c:188
+msgid "Tab     Toggle view mode (F3/F4/F5)"
+msgstr "Tab     Choisir le mode de visualisation (F3/F4/F5)"
+
+#: ../alsamixer/mixer_widget.c:189
+msgid "F6 S    Select sound card"
+msgstr "F6 S    Choisir la carte son"
+
+#: ../alsamixer/mixer_widget.c:190
+msgid "L       Redraw screen"
+msgstr "L       Actualiser l'écran"
+
+#: ../alsamixer/mixer_widget.c:192
+msgid "Left    Move to the previous control"
+msgstr "Gauche  Aller à la commande précédente"
+
+#: ../alsamixer/mixer_widget.c:193
+msgid "Right   Move to the next control"
+msgstr "Droite  Aller à la commande suivante"
+
+#: ../alsamixer/mixer_widget.c:195
+msgid "Up/Down    Change volume"
+msgstr "Haut/Bas   Ajuster le volume"
+
+#: ../alsamixer/mixer_widget.c:196
+msgid "+ -        Change volume"
+msgstr "+ -        Ajuster le volume"
+
+#: ../alsamixer/mixer_widget.c:197
+msgid "Page Up/Dn Change volume in big steps"
+msgstr "Page Préc./Suiv. Ajuster le volume en grandes intervalles"
+
+#: ../alsamixer/mixer_widget.c:198
+msgid "End        Set volume to 0%"
+msgstr "Fin        Couper le volume"
+
+#: ../alsamixer/mixer_widget.c:199
+msgid "0-9        Set volume to 0%-90%"
+msgstr "0-9        Ajuster le volume entre 0 et 90%"
+
+#: ../alsamixer/mixer_widget.c:200
+msgid "Q W E      Increase left/both/right volumes"
+msgstr "Q W E      Augmenter les volumes de gauche/centre/droite"
+
+#. TRANSLATORS: or Y instead of Z
+#: ../alsamixer/mixer_widget.c:202
+msgid "Z X C      Decrease left/both/right volumes"
+msgstr "Z X C      Baisser les volumes de gauche/centre/droite"
+
+#: ../alsamixer/mixer_widget.c:203
+msgid "B          Balance left and right volumes"
+msgstr "B          Égaliser les volumes de gauche et droite"
+
+#: ../alsamixer/mixer_widget.c:205
+msgid "M          Toggle mute"
+msgstr "M          (Dés)activer le mode muet"
+
+#. TRANSLATORS: or , .
+#: ../alsamixer/mixer_widget.c:207
+msgid "< >        Toggle left/right mute"
+msgstr "< >        (Dés)activer le mode muet à gauche et à droite"
+
+#: ../alsamixer/mixer_widget.c:209
+msgid "Space      Toggle capture"
+msgstr "Espace     (Dés)activer la capture"
+
+#. TRANSLATORS: or Insert Delete
+#: ../alsamixer/mixer_widget.c:211
+msgid "; '        Toggle left/right capture"
+msgstr ";          (Dés)activer la capture à gauche et à droite"
+
+#: ../alsamixer/mixer_widget.c:213
+msgid "Authors:"
+msgstr "Auteurs:"
+
+#: ../alsamixer/mixer_widget.c:214
+msgid "  Tim Janik <timj@gtk.org>"
+msgstr ""
+
+#: ../alsamixer/mixer_widget.c:215
+msgid "  Jaroslav Kysela <perex@perex.cz>"
+msgstr ""
+
+#: ../alsamixer/mixer_widget.c:216
+msgid "  Clemens Ladisch <clemens@ladisch.de>"
+msgstr ""
+
+#: ../alsamixer/mixer_widget.c:218
+msgid "Help"
+msgstr "Aide"
+
+#: ../alsamixer/proc_files.c:103
+msgid "Select File"
+msgstr "Choisir un Fichier"
+
+#: ../alsamixer/textbox.c:52 ../alsamixer/textbox.c:66
+msgid "Error"
+msgstr "Erreur"
+
+#: ../alsamixer/textbox.c:80
+#, c-format
+msgid "Cannot open file \"%s\"."
+msgstr "Le fichier \"%s\" n'a pas pu être ouvert."
+
+#: ../aplay/aplay.c:147
+msgid "raw data"
+msgstr "données brutes"
+
+#: ../aplay/aplay.c:148
+msgid "VOC"
+msgstr ""
+
+#. FIXME: can WAV handle exactly 2GB or less than it?
+#: ../aplay/aplay.c:150
+msgid "WAVE"
+msgstr ""
+
+#: ../aplay/aplay.c:151
+msgid "Sparc Audio"
+msgstr ""
+
+#: ../aplay/aplay.c:172
+#, c-format
+msgid ""
+"Usage: %s [OPTION]... [FILE]...\n"
+"\n"
+"-h, --help              help\n"
+"    --version           print current version\n"
+"-l, --list-devices      list all soundcards and digital audio devices\n"
+"-L, --list-pcms         list device names\n"
+"-D, --device=NAME       select PCM by name\n"
+"-q, --quiet             quiet mode\n"
+"-t, --file-type TYPE    file type (voc, wav, raw or au)\n"
+"-c, --channels=#        channels\n"
+"-f, --format=FORMAT     sample format (case insensitive)\n"
+"-r, --rate=#            sample rate\n"
+"-d, --duration=#        interrupt after # seconds\n"
+"-M, --mmap              mmap stream\n"
+"-N, --nonblock          nonblocking mode\n"
+"-F, --period-time=#     distance between interrupts is # microseconds\n"
+"-B, --buffer-time=#     buffer duration is # microseconds\n"
+"    --period-size=#     distance between interrupts is # frames\n"
+"    --buffer-size=#     buffer duration is # frames\n"
+"-A, --avail-min=#       min available space for wakeup is # microseconds\n"
+"-R, --start-delay=#     delay for automatic PCM start is # microseconds \n"
+"                        (relative to buffer size if <= 0)\n"
+"-T, --stop-delay=#      delay for automatic PCM stop is # microseconds from "
+"xrun\n"
+"-v, --verbose           show PCM structure and setup (accumulative)\n"
+"-V, --vumeter=TYPE      enable VU meter (TYPE: mono or stereo)\n"
+"-I, --separate-channels one file for each channel\n"
+"    --disable-resample  disable automatic rate resample\n"
+"    --disable-channels  disable automatic channel conversions\n"
+"    --disable-format    disable automatic format conversions\n"
+"    --disable-softvol   disable software volume control (softvol)\n"
+"    --test-position     test ring buffer position\n"
+"    --test-coef=#\t test coeficient for ring buffer position (default 8)\n"
+"                        expression for validation is: coef * (buffer_size / "
+"2)\n"
+"    --test-nowait       do not wait for ring buffer - eats whole CPU\n"
+"    --max-file-time=#   start another output file when the old file has "
+"recorded\n"
+"                        for this many seconds\n"
+"    --process-id-file   write the process ID here\n"
+"    --use-strftime      apply the strftime facility to the output file name\n"
+msgstr ""
+"Utilisation: %s [OPTION]... [FICHIER]...\n"
+"\n"
+"-h, --help              aide\n"
+"    --version           afficher la version du programme\n"
+"-l, --list-devices      afficher la listes des périphériques\n"
+"-L, --list-pcms         afficher la liste des noms de périphériques\n"
+"-D, --device=NOM        choisir le périphérique PCM par son nom\n"
+"-Q, --quiet             mode silencieux\n"
+"-t, --file-type TYPE    type de fichier (voc, wav, raw ou au)\n"
+"-c, --channels=#        canaux\n"
+"-f, --format=FORMAT     format d'échantillonage (insensible à la casse)\n"
+"-r, --rate=#            fréquence d'échantillonage\n"
+"-d, --duration=#        interrompre après # secondes\n"
+"-M, --mmap              charger le flux en mémoire avec mmap\n"
+"-N, --nonblock          mode non-bloquant\n"
+"-F, --period-time=#     # microsecondes entre chaque interruption\n"
+"-B, --buffer-time=#     la durée du tampon est de # microsecondes\n"
+"    --period-size=#     # trames entre chaque interruption\n"
+"    --buffer-size=#     la durée du tampon est de # trames\n"
+"-A, --avail-min=#       # microsecondes min. disponibles entre chaque réveil\n"
+"-R, --start-delay=#     # microsecondes de délai avant le démarrage\n"
+"                        automatique du périphérique PCM (relatif à la taille\n"
+"                        du tampon si <= 0)\n"
+"-T, --stop-delay=#      # microsecondes de délai depuis xrun avant l'arrêt\n"
+"                        automatique du périphérique PCM \n"
+"-v, --verbose           afficher la structure et la configuration du\n"
+"                        périphérique PCM (accumulatif)\n"
+"-V, --vumeter=TYPE      activer le VU-mètre (TYPE: mono ou stereo)\n"
+"-I, --separate-channels un fichier par canal\n"
+"    --disable-resample  désactiver le rééchantillonage de fréquence\n"
+"                        automatique\n"
+"    --disable-channels  désactiver les conversions automatiques de canal\n"
+"    --disable-format    désactiver les conversions automatiques de format\n"
+"    --disable-softvol   désactiver la commande du volume logicielle\n"
+"    --test-position     tester la position du tampon circulaire\n"
+"    --test-coef=#       test coefficient pour la position du tampon\n"
+"                        circulaire (par défaut 8). L'expression pour la\n"
+"                        validation est : coef * (taille_tampon / 2)\n"
+"    --test-nowait       ne pas attendre le tampon circulaire - prend toutes\n"
+"                        les resources du processeur\n"
+"    --max-file-time=#   commencer un autre fichier de capture quand l'ancien\n"
+"                        fichier a enregistré pendant # secondes\n"
+"    --process-id-file   écrire l'identifiant du processus ici\n"
+"    --use-strftime      utiliser strftime pour le nom du fichier de capture\n"
+
+#: ../aplay/aplay.c:211 ../speaker-test/speaker-test.c:750
+#, c-format
+msgid "Recognized sample formats are:"
+msgstr "Les formats d'échantillonage connus sont:"
+
+#: ../aplay/aplay.c:217
+#, c-format
+msgid ""
+"\n"
+"Some of these may not be available on selected hardware\n"
+msgstr ""
+"\n"
+"Certains de ceux-ci ne sont peut être pas disponibles avec ce matériel\n"
+
+#: ../aplay/aplay.c:218
+#, c-format
+msgid "The availabled format shortcuts are:\n"
+msgstr "Les raccourcis format disponibles sont:\n"
+
+#: ../aplay/aplay.c:219
+#, c-format
+msgid "-f cd (16 bit little endian, 44100, stereo)\n"
+msgstr "-f cd (16 bit petit boutiste, 44100, stéréo)\n"
+
+#: ../aplay/aplay.c:220
+#, c-format
+msgid "-f cdr (16 bit big endian, 44100, stereo)\n"
+msgstr "-f cdr (16 bit gros boutiste, 44100, stéréo)\n"
+
+#: ../aplay/aplay.c:221
+#, c-format
+msgid "-f dat (16 bit little endian, 48000, stereo)\n"
+msgstr "-f dat (16 bit petit boutiste, 48000, stéréo)\n"
+
+#: ../aplay/aplay.c:235
+msgid "no soundcards found..."
+msgstr "aucune carte son n'a été trouvée..."
+
+#: ../aplay/aplay.c:238
+#, c-format
+msgid "**** List of %s Hardware Devices ****\n"
+msgstr "**** Liste des Périphériques Matériels %s ****\n"
+
+#: ../aplay/aplay.c:267
+#, c-format
+msgid "card %i: %s [%s], device %i: %s [%s]\n"
+msgstr "carte %i: %s [%s], périphérique %i: %s [%s]\n"
+
+#: ../aplay/aplay.c:273
+#, c-format
+msgid "  Subdevices: %i/%i\n"
+msgstr "  Sous-périphériques: %i/%i\n"
+
+#: ../aplay/aplay.c:280
+#, c-format
+msgid "  Subdevice #%i: %s\n"
+msgstr "  Sous-périphérique #%i: %s\n"
+
+#: ../aplay/aplay.c:356
+#, c-format
+msgid "Aborted by signal %s...\n"
+msgstr "Interrompu par le signal %s...\n"
+
+#: ../aplay/aplay.c:467
+msgid "command should be named either arecord or aplay"
+msgstr "la commande doit être nommée arecord ou aplay"
+
+#: ../aplay/aplay.c:506
+#, c-format
+msgid "unrecognized file format %s"
+msgstr "format de fichier inconnu %s"
+
+#: ../aplay/aplay.c:513
+#, c-format
+msgid "value %i for channels is invalid"
+msgstr "la valeur %i pour les canaux est incorrecte"
+
+#: ../aplay/aplay.c:532
+#, c-format
+msgid "wrong extended format '%s'"
+msgstr "format étendu '%s' erronné"
+
+#: ../aplay/aplay.c:543
+#, c-format
+msgid "bad speed value %i"
+msgstr "mauvaise valeur de vitesse %i"
+
+#: ../aplay/aplay.c:638
+#, c-format
+msgid "Try `%s --help' for more information.\n"
+msgstr "Essayez `%s --help' pour plus d'informations.\n"
+
+#: ../aplay/aplay.c:654
+#, c-format
+msgid "audio open error: %s"
+msgstr "erreur à l'ouverture audio: %s"
+
+#: ../aplay/aplay.c:659
+#, c-format
+msgid "info error: %s"
+msgstr "erreur info: %s"
+
+#: ../aplay/aplay.c:666
+#, c-format
+msgid "nonblock setting error: %s"
+msgstr "paramètre de non-blocage erronné: %s"
+
+#: ../aplay/aplay.c:676 ../aplay/aplay.c:800 ../aplay/aplay.c:1167
+msgid "not enough memory"
+msgstr "pas assez de mémoire"
+
+#: ../aplay/aplay.c:700
+#, c-format
+msgid "Cannot create process ID file %s: %s"
+msgstr "Le fichier de numéro de processus %s n'a pas pu être créé: %s"
+
+#: ../aplay/aplay.c:790
+#, c-format
+msgid "read error (called from line %i)"
+msgstr "erreur de lecture (appelé à la ligne %i)"
+
+#: ../aplay/aplay.c:848
+#, c-format
+msgid "unknown length of 'fmt ' chunk (read %u, should be %u at least)"
+msgstr "longueur du morceau 'fmt ' inconnue (lu %u, devrait être au moins %u)"
+
+#: ../aplay/aplay.c:858
+#, c-format
+msgid ""
+"unknown length of extensible 'fmt ' chunk (read %u, should be %u at least)"
+msgstr ""
+"longueur du morceau 'fmt ' extensible inconnue (lu %u, devrait être au moins %u)"
+
+#: ../aplay/aplay.c:863
+msgid "wrong format tag in extensible 'fmt ' chunk"
+msgstr "libellé de format erronné dans le morceau extensible 'fmt '"
+
+#: ../aplay/aplay.c:870
+#, c-format
+msgid "can't play WAVE-file format 0x%04x which is not PCM or FLOAT encoded"
+msgstr "Les formats de ficher WAVE 0x%04x qui ne sont pas encodés en PCM ou"
+       "FLOAT ne sont pas supportés"
+
+#: ../aplay/aplay.c:874
+#, c-format
+msgid "can't play WAVE-files with %d tracks"
+msgstr "Les fichiers WAVE avec %d pistes ne sont pas supportés"
+
+#: ../aplay/aplay.c:882 ../aplay/aplay.c:982
+#, c-format
+msgid "Warning: format is changed to U8\n"
+msgstr "Avertissement: le format est changé en U8\n"
+
+#: ../aplay/aplay.c:888
+#, c-format
+msgid "Warning: format is changed to S16_LE\n"
+msgstr "Avertissement: le format est changé en S16_LE\n"
+
+#: ../aplay/aplay.c:896
+#, c-format
+msgid "Warning: format is changed to S24_3LE\n"
+msgstr "Avertissement: le format est changé en S24_3LE\n"
+
+#: ../aplay/aplay.c:902
+#, c-format
+msgid "Warning: format is changed to S24_LE\n"
+msgstr "Avertissement: le format est changé en S24_LE\n"
+
+#: ../aplay/aplay.c:906
+#, c-format
+msgid ""
+" can't play WAVE-files with sample %d bits in %d bytes wide (%d channels)"
+msgstr ""
+" les fichiers WAVE échantillonés %d bits par %d octets en largeur (%d canaux)"
+"ne sont pas supportés"
+
+#: ../aplay/aplay.c:918
+#, c-format
+msgid " can't play WAVE-files with sample %d bits wide"
+msgstr " les fichiers WAVES échantillonés %d bits en largeur ne sont pas"
+"supportés"
+
+#: ../aplay/aplay.c:976
+#, c-format
+msgid "Warning: format is changed to MU_LAW\n"
+msgstr "Avertissement: le format est changé en MU_LAW\n"
+
+#: ../aplay/aplay.c:988
+#, c-format
+msgid "Warning: format is changed to S16_BE\n"
+msgstr "Avertissement: le format est changé en S16_BE\n"
+
+#: ../aplay/aplay.c:1001 ../aplay/aplay.c:1843 ../aplay/aplay.c:1850
+#: ../aplay/aplay.c:2372 ../aplay/aplay.c:2384
+msgid "read error"
+msgstr "erreur de lecture"
+
+#: ../aplay/aplay.c:1031
+msgid "Broken configuration for this PCM: no configurations available"
+msgstr "Configuration erronée pour ce périphérique PCM: pas de configuration"
+
+#: ../aplay/aplay.c:1048
+msgid "Access type not available"
+msgstr "Ce type d'accès n'est pas disponible"
+
+#: ../aplay/aplay.c:1053
+msgid "Sample format non available"
+msgstr "Ce format d'échantillonage n'est pas disponible"
+
+#: ../aplay/aplay.c:1059
+msgid "Channels count non available"
+msgstr "Nombre de canaux non disponible"
+
+#: ../aplay/aplay.c:1074
+#, c-format
+msgid "Warning: rate is not accurate (requested = %iHz, got = %iHz)\n"
+msgstr "Avertissement: la fréquence n'est pas précise (demandé = %iHz,\n"
+       "obtenu = %iHz)\n"
+
+#: ../aplay/aplay.c:1080
+#, c-format
+msgid "         please, try the plug plugin %s\n"
+msgstr "         veuillez essayez le greffon de branchement %s\n"
+
+#: ../aplay/aplay.c:1116
+msgid "Unable to install hw params:"
+msgstr "Les paramètres matériel n'ont pas pu être installés:"
+
+#: ../aplay/aplay.c:1123
+#, c-format
+msgid "Can't use period equal to buffer size (%lu == %lu)"
+msgstr "Une période égale à la taille du tampon (%lu == %lu) ne peut être"
+       "utilisée"
+
+#: ../aplay/aplay.c:1154
+msgid "unable to install sw params:"
+msgstr "Les paramètres logiciel n'ont pas pu être installés:"
+
+#: ../aplay/aplay.c:1229
+#, c-format
+msgid "status error: %s"
+msgstr "erreur d'état: %s"
+
+#: ../aplay/aplay.c:1239 ../aplay/aplay.c:1250
+#, c-format
+msgid "%s!!! (at least %.3f ms long)\n"
+msgstr "%s!!! (au moins longue de %.3f ms)\n"
+
+#: ../aplay/aplay.c:1240 ../aplay/aplay.c:1243 ../aplay/aplay.c:1251
+msgid "underrun"
+msgstr "perte"
+
+#: ../aplay/aplay.c:1240 ../aplay/aplay.c:1251
+msgid "overrun"
+msgstr "dépassement"
+
+#: ../aplay/aplay.c:1255
+#, c-format
+msgid "Status:\n"
+msgstr "État:\n"
+
+#: ../aplay/aplay.c:1259
+#, c-format
+msgid "xrun: prepare error: %s"
+msgstr ""
+
+#: ../aplay/aplay.c:1265
+#, c-format
+msgid "Status(DRAINING):\n"
+msgstr ""
+
+#: ../aplay/aplay.c:1269
+#, c-format
+msgid "capture stream format change? attempting recover...\n"
+msgstr "changement de format de flux de capture? tentative de récupération...\n"
+
+#: ../aplay/aplay.c:1271
+#, c-format
+msgid "xrun(DRAINING): prepare error: %s"
+msgstr ""
+
+#: ../aplay/aplay.c:1278
+#, c-format
+msgid "Status(R/W):\n"
+msgstr ""
+
+#: ../aplay/aplay.c:1281
+#, c-format
+msgid "read/write error, state = %s"
+msgstr "erreur de lecture/écriture, état = %s"
+
+#: ../aplay/aplay.c:1291
+#, c-format
+msgid "Suspended. Trying resume. "
+msgstr "Suspendu. Tentative de reprise. "
+
+#: ../aplay/aplay.c:1296
+#, c-format
+msgid "Failed. Restarting stream. "
+msgstr "Échec. Redémarrage du flux."
+
+#: ../aplay/aplay.c:1298
+#, c-format
+msgid "suspend: prepare error: %s"
+msgstr "suspension: prepare error: %s"
+
+#: ../aplay/aplay.c:1303
+#, c-format
+msgid "Done.\n"
+msgstr "Terminé.\n"
+
+#: ../aplay/aplay.c:1325
+#, c-format
+msgid " !clip  "
+msgstr ""
+
+#: ../aplay/aplay.c:1472
+#, c-format
+msgid "Unsupported bit size %d.\n"
+msgstr "%d bit(s) non supporté(s).\n"
+
+#: ../aplay/aplay.c:1506
+#, c-format
+msgid "Max peak (%li samples): 0x%08x "
+msgstr "Pic max. (%li échantillons): 0x%08x "
+
+#: ../aplay/aplay.c:1540
+#, c-format
+msgid ""
+"Suspicious buffer position (%li total): avail = %li, delay = %li, buffer = %"
+"li\n"
+msgstr ""
+"Position de tampon suspicieuse (total %li): dispo = %li, délai = %li, tampon ="
+" %li\n"
+
+#: ../aplay/aplay.c:1603
+#, c-format
+msgid "write error: %s"
+msgstr "erreur en écriture: %s"
+
+#: ../aplay/aplay.c:1649
+#, c-format
+msgid "writev error: %s"
+msgstr "erreur de writev: %s"
+
+#: ../aplay/aplay.c:1692
+#, c-format
+msgid "read error: %s"
+msgstr "erreur en lecture: %s"
+
+#: ../aplay/aplay.c:1735
+#, c-format
+msgid "readv error: %s"
+msgstr "erreur de readv: %s"
+
+#: ../aplay/aplay.c:1783
+msgid "can't allocate buffer for silence"
+msgstr "Un tampon pour silence n'a pas pu être alloué"
+
+#. to stderr
+#: ../aplay/aplay.c:1792 ../aplay/aplay.c:2018 ../aplay/aplay.c:2023
+#: ../aplay/aplay.c:2070 ../aplay/aplay.c:2079 ../aplay/aplay.c:2086
+#: ../aplay/aplay.c:2096 ../aplay/aplay.c:2102 ../aplay/aplay.c:2174
+#: ../aplay/aplay.c:2204 ../aplay/aplay.c:2218
+msgid "write error"
+msgstr "erreur en écriture"
+
+#: ../aplay/aplay.c:1805
+#, c-format
+msgid "voc_pcm_flush - silence error"
+msgstr "voc_pcm_flush - erreur de silence"
+
+#: ../aplay/aplay.c:1808
+msgid "voc_pcm_flush error"
+msgstr "erreur voc_pcm_flush"
+
+#: ../aplay/aplay.c:1834
+msgid "malloc error"
+msgstr "erreur malloc"
+
+#: ../aplay/aplay.c:1838
+#, c-format
+msgid "Playing Creative Labs Channel file '%s'...\n"
+msgstr "Lecture du ficher de canaux Creative Labs '%s'...\n"
+
+#. /dev/dsp can't it
+#: ../aplay/aplay.c:1906 ../aplay/aplay.c:1998
+msgid "can't play packed .voc files"
+msgstr "les fichiers .voc de type 'packed' ne sont pas supportés"
+
+#: ../aplay/aplay.c:1958
+#, c-format
+msgid "can't play loops; %s isn't seekable\n"
+msgstr "%s n'est pas navigable; les motifs n'ont pas pu être lus\n"
+
+#: ../aplay/aplay.c:2007
+#, c-format
+msgid "unknown blocktype %d. terminate."
+msgstr "type de bloc %d inconnu. fin."
+
+#: ../aplay/aplay.c:2138
+#, c-format
+msgid "Wave doesn't support %s format..."
+msgstr "Le format wave %s n'est pas supporté..."
+
+#: ../aplay/aplay.c:2198
+#, c-format
+msgid "Sparc Audio doesn't support %s format..."
+msgstr "Le format %s Sparc Audio n'est pas supporté..."
+
+#: ../aplay/aplay.c:2279
+msgid "Playing"
+msgstr "Lecture"
+
+#: ../aplay/aplay.c:2279
+msgid "Recording"
+msgstr "Capture"
+
+#: ../aplay/aplay.c:2283
+#, c-format
+msgid "Rate %d Hz, "
+msgstr "Fréquence %d Hz, "
+
+#: ../aplay/aplay.c:2285
+#, c-format
+msgid "Mono"
+msgstr ""
+
+#: ../aplay/aplay.c:2287
+#, c-format
+msgid "Stereo"
+msgstr "Stéréo"
+
+#: ../aplay/aplay.c:2289
+#, c-format
+msgid "Channels %i"
+msgstr "%i Canaux"
+
+#: ../aplay/aplay.c:2798 ../aplay/aplay.c:2851
+#, c-format
+msgid "You need to specify %d files"
+msgstr "Vous devez spécifier %d fichiers"
+
+#: ../seq/aconnect/aconnect.c:49
+#, c-format
+msgid "aconnect - ALSA sequencer connection manager\n"
+msgstr "aconnect - gestionnaire de connection séquenceur ALSA\n"
+
+#: ../seq/aconnect/aconnect.c:50
+#, c-format
+msgid "Copyright (C) 1999-2000 Takashi Iwai\n"
+msgstr ""
+
+#: ../seq/aconnect/aconnect.c:51
+#, c-format
+msgid "Usage:\n"
+msgstr "Utilisation:\n"
+
+#: ../seq/aconnect/aconnect.c:52
+#, c-format
+msgid " * Connection/disconnection between two ports\n"
+msgstr " * Connexion/déconnexion entre deux ports\n"
+
+#: ../seq/aconnect/aconnect.c:53
+#, c-format
+msgid "   aconnect [-options] sender receiver\n"
+msgstr "   aconnect [-options] envoyeur destinataire\n"
+
+#: ../seq/aconnect/aconnect.c:54
+#, c-format
+msgid "     sender, receiver = client:port pair\n"
+msgstr "     envoyeur, destinataire = couple client:port\n"
+
+#: ../seq/aconnect/aconnect.c:55
+#, c-format
+msgid "     -d,--disconnect     disconnect\n"
+msgstr "     -d,--disconnect     déconnecter\n"
+
+#: ../seq/aconnect/aconnect.c:56
+#, c-format
+msgid "     -e,--exclusive      exclusive connection\n"
+msgstr "     -e,--exclusive      connexion exclusive\n"
+
+#: ../seq/aconnect/aconnect.c:57
+#, c-format
+msgid "     -r,--real #         convert real-time-stamp on queue\n"
+msgstr ""
+
+#: ../seq/aconnect/aconnect.c:58
+#, c-format
+msgid "     -t,--tick #         convert tick-time-stamp on queue\n"
+msgstr ""
+
+#: ../seq/aconnect/aconnect.c:59
+#, c-format
+msgid " * List connected ports (no subscription action)\n"
+msgstr " * Afficher la liste des ports connectés (pas de souscription)\n"
+
+#: ../seq/aconnect/aconnect.c:60
+#, c-format
+msgid "   aconnect -i|-o [-options]\n"
+msgstr "   aconnect -i|-o [-options]\n"
+
+#: ../seq/aconnect/aconnect.c:61
+#, c-format
+msgid "     -i,--input          list input (readable) ports\n"
+msgstr "     -i,--input          afficher la liste des ports d'entrée\n"
+
+#: ../seq/aconnect/aconnect.c:62
+#, c-format
+msgid "     -o,--output         list output (writable) ports\n"
+msgstr "     -o,--output         afficher la liste des ports de sortie\n"
+
+#: ../seq/aconnect/aconnect.c:63
+#, c-format
+msgid "     -l,--list           list current connections of each port\n"
+msgstr "     -l,--list           afficher la liste des connexions en cours\n"
+       "                         sur chaque port\n"
+
+#: ../seq/aconnect/aconnect.c:64
+#, c-format
+msgid " * Remove all exported connections\n"
+msgstr " * Retirer toutes les connexions exportées\n"
+
+#: ../seq/aconnect/aconnect.c:65
+#, c-format
+msgid "     -x, --removeall\n"
+msgstr "     -x, --removeall\n"
+
+#: ../seq/aconnect/aconnect.c:132
+msgid "Connecting To"
+msgstr "Connexion À"
+
+#: ../seq/aconnect/aconnect.c:133
+msgid "Connected From"
+msgstr "Connecté Depuis"
+
+#: ../seq/aconnect/aconnect.c:169
+#, c-format
+msgid "client %d: '%s' [type=%s]\n"
+msgstr "client %d: '%s' [type=%s]\n"
+
+#: ../seq/aconnect/aconnect.c:173
+msgid "user"
+msgstr "utilisateur"
+
+#: ../seq/aconnect/aconnect.c:173
+msgid "kernel"
+msgstr "noyau"
+
+#: ../seq/aconnect/aconnect.c:307
+#, c-format
+msgid "can't open sequencer\n"
+msgstr "le séquenceur n'a pas pu être ouvert\n"
+
+#: ../seq/aconnect/aconnect.c:335
+#, c-format
+msgid "can't get client id\n"
+msgstr "l'identifiant du client n'as pas pu être obtenu\n"
+
+#: ../seq/aconnect/aconnect.c:342
+#, c-format
+msgid "can't set client info\n"
+msgstr "les infos du client n'ont pas pu être définies\n"
+
+#: ../seq/aconnect/aconnect.c:349
+#, c-format
+msgid "invalid sender address %s\n"
+msgstr "l'addresse envoyeur %s est incorrecte\n"
+
+#: ../seq/aconnect/aconnect.c:354 ../seq/aseqnet/aseqnet.c:290
+#, c-format
+msgid "invalid destination address %s\n"
+msgstr "l'addresse destinataire %s est incorrecte\n"
+
+#: ../seq/aconnect/aconnect.c:368
+#, c-format
+msgid "No subscription is found\n"
+msgstr "Aucune souscription trouvée\n"
+
+#: ../seq/aconnect/aconnect.c:373
+#, c-format
+msgid "Disconnection failed (%s)\n"
+msgstr "La déconnexion a échoué (%s)\n"
+
+#: ../seq/aconnect/aconnect.c:379
+#, c-format
+msgid "Connection is already subscribed\n"
+msgstr "La connexion a déjà été souscrite\n"
+
+#: ../seq/aconnect/aconnect.c:384
+#, c-format
+msgid "Connection failed (%s)\n"
+msgstr "Échec de connexion (%s)\n"
+
+#: ../seq/aseqnet/aseqnet.c:164
+#, c-format
+msgid "aseqnet - network client/server on ALSA sequencer\n"
+msgstr "aseqnet - client/serveur réseau sur le séquenceur ALSA\n"
+
+#: ../seq/aseqnet/aseqnet.c:165
+#, c-format
+msgid "  Copyright (C) 1999 Takashi Iwai\n"
+msgstr ""
+
+#: ../seq/aseqnet/aseqnet.c:166
+#, c-format
+msgid "usage:\n"
+msgstr "utilisation:\n"
+
+#: ../seq/aseqnet/aseqnet.c:167
+#, c-format
+msgid "  server mode: aseqnet [-options]\n"
+msgstr "  mode serveur: aseqnet [-options]\n"
+
+#: ../seq/aseqnet/aseqnet.c:168
+#, c-format
+msgid "  client mode: aseqnet [-options] server_host\n"
+msgstr "  mode client: aseqnet [-options] hôte_serveur\n"
+
+#: ../seq/aseqnet/aseqnet.c:169
+#, c-format
+msgid "options:\n"
+msgstr "options:\n"
+
+#: ../seq/aseqnet/aseqnet.c:170
+#, c-format
+msgid "  -p,--port # : sepcify TCP port (digit or service name)\n"
+msgstr "  -p,--port # : spécifier le port TCP (numéro ou nom de service)\n"
+
+#: ../seq/aseqnet/aseqnet.c:171
+#, c-format
+msgid "  -s,--source addr : read from given addr (client:port)\n"
+msgstr "  -s,--source addr : lire à partir de l'addr. donnée (client:port)\n"
+
+#: ../seq/aseqnet/aseqnet.c:172
+#, c-format
+msgid "  -d,--dest addr : write to given addr (client:port)\n"
+msgstr "  -d,--dest addr : écrire à l'addr. donnée (client:port)\n"
+
+#: ../seq/aseqnet/aseqnet.c:173
+#, c-format
+msgid "  -v, --verbose : print verbose messages\n"
+msgstr "  -v, --verbose : affichage locace de messages\n"
+
+#: ../seq/aseqnet/aseqnet.c:174
+#, c-format
+msgid "  -i, --info : print certain received events\n"
+msgstr "  -i, --info : afficher certains évènements reçus\n"
+
+#: ../seq/aseqnet/aseqnet.c:188
+#, c-format
+msgid "can't malloc\n"
+msgstr "échec allocation mémoire (malloc)\n"
+
+#: ../seq/aseqnet/aseqnet.c:213
+#, c-format
+msgid "closing files..\n"
+msgstr "fermeture des fichiers...\n"
+
+#: ../seq/aseqnet/aseqnet.c:272
+#, c-format
+msgid "sequencer opened: %d:%d\n"
+msgstr "séquenceur ouvert: %d:%d\n"
+
+#: ../seq/aseqnet/aseqnet.c:279
+#, c-format
+msgid "invalid source address %s\n"
+msgstr "addresse source %s incorrecte\n"
+
+#: ../seq/aseqnet/aseqnet.c:309
+#, c-format
+msgid "service '%s' is not found in /etc/services\n"
+msgstr "le service '%s' n'as pas été trouvé dans /etc/services\n"
+
+#: ../seq/aseqnet/aseqnet.c:377
+#, c-format
+msgid "too many connections!\n"
+msgstr "trop de connexions!\n"
+
+#: ../seq/aseqnet/aseqnet.c:388
+#, c-format
+msgid "accepted[%d]\n"
+msgstr "accepté[%d]\n"
+
+#: ../seq/aseqnet/aseqnet.c:411
+#, c-format
+msgid "can't get address %s\n"
+msgstr "l'addresse %s na pas pu être obtenue\n"
+
+#: ../seq/aseqnet/aseqnet.c:422
+#, c-format
+msgid "ok.. connected\n"
+msgstr "ok.. connecté\n"
+
+#: ../seq/aseqnet/aseqnet.c:518
+#, c-format
+msgid "Channel %2d: Control event : %5d\n"
+msgstr "Canal %2d: Évènement de contrôle: %5d\n"
+
+#: ../seq/aseqnet/aseqnet.c:522
+#, c-format
+msgid "Channel %2d: Pitchbender   : %5d\n"
+msgstr "Canal %2d: Pitchbender          : %5d\n"
+
+#: ../seq/aseqnet/aseqnet.c:526
+#, c-format
+msgid "Channel %2d: Note On event : %5d\n"
+msgstr "Canal %2d: évènement Note On    : %5d\n"
+
+#: ../seq/aseqnet/aseqnet.c:530
+#, c-format
+msgid "Channel %2d: Note Off event: %5d\n"
+msgstr "Canal %2d: évènement Note Off   : %5d\n"
+
+#: ../seq/aseqnet/aseqnet.c:585
+#, c-format
+msgid "disconnected\n"
+msgstr "déconnecté\n"
+
+#. 0
+#: ../speaker-test/speaker-test.c:103
+msgid "Front Left"
+msgstr "Avant Gauche"
+
+#. 1
+#: ../speaker-test/speaker-test.c:104
+msgid "Front Right"
+msgstr "Avant Droit"
+
+#. 2
+#: ../speaker-test/speaker-test.c:105
+msgid "Rear Left"
+msgstr "Arrière Gauche"
+
+#. 3
+#: ../speaker-test/speaker-test.c:106
+msgid "Rear Right"
+msgstr "Arrière Droit"
+
+#. 5
+#: ../speaker-test/speaker-test.c:108
+msgid "LFE"
+msgstr ""
+
+#. 6
+#: ../speaker-test/speaker-test.c:109
+msgid "Side Left"
+msgstr "Côté Gauche"
+
+#. 7
+#: ../speaker-test/speaker-test.c:110
+msgid "Side Right"
+msgstr "Côté Droit"
+
+#. 8
+#: ../speaker-test/speaker-test.c:111
+msgid "Channel 9"
+msgstr "Canal 9"
+
+#. 9
+#: ../speaker-test/speaker-test.c:112
+msgid "Channel 10"
+msgstr "Canal 10"
+
+#. 10
+#: ../speaker-test/speaker-test.c:113
+msgid "Channel 11"
+msgstr "Canal 11"
+
+#. 11
+#: ../speaker-test/speaker-test.c:114
+msgid "Channel 12"
+msgstr "Canal 12"
+
+#. 12
+#: ../speaker-test/speaker-test.c:115
+msgid "Channel 13"
+msgstr "Canal 13"
+
+#. 13
+#: ../speaker-test/speaker-test.c:116
+msgid "Channel 14"
+msgstr "Canal 14"
+
+#. 14
+#: ../speaker-test/speaker-test.c:117
+msgid "Channel 15"
+msgstr "Canal 15"
+
+#. 15
+#: ../speaker-test/speaker-test.c:118
+msgid "Channel 16"
+msgstr "Canal 16"
+
+#: ../speaker-test/speaker-test.c:317
+#, c-format
+msgid "Broken configuration for playback: no configurations available: %s\n"
+msgstr "Configuration erronée pour la lecture: pas de configuration: %s\n"
+
+#: ../speaker-test/speaker-test.c:324
+#, c-format
+msgid "Access type not available for playback: %s\n"
+msgstr "Le type d'accès est indisponible à la lecture: %s\n"
+
+#: ../speaker-test/speaker-test.c:331
+#, c-format
+msgid "Sample format not available for playback: %s\n"
+msgstr "Le format d'échantillonage est indisponible à la lecture: %s\n"
+
+#: ../speaker-test/speaker-test.c:338
+#, c-format
+msgid "Channels count (%i) not available for playbacks: %s\n"
+msgstr "Le nombre (%i) de canaux est indisponible à la lecture: %s\n"
+
+#: ../speaker-test/speaker-test.c:346
+#, c-format
+msgid "Rate %iHz not available for playback: %s\n"
+msgstr "La fréquence %iHz est indisponible à la lecture: %s\n"
+
+#: ../speaker-test/speaker-test.c:351
+#, c-format
+msgid "Rate doesn't match (requested %iHz, get %iHz, err %d)\n"
+msgstr "La fréquence ne correspond pas (demandée: %iHz, obtenue %iHz, err %d)\n"
+
+#: ../speaker-test/speaker-test.c:355
+#, c-format
+msgid "Rate set to %iHz (requested %iHz)\n"
+msgstr "La fréquence est %iHz (demandée %iHz)\n"
+
+#: ../speaker-test/speaker-test.c:361
+#, c-format
+msgid "Buffer size range from %lu to %lu\n"
+msgstr "L'intervalle de la taille du tampon est de %lu à %lu\n"
+
+#: ../speaker-test/speaker-test.c:362
+#, c-format
+msgid "Period size range from %lu to %lu\n"
+msgstr "L'intervalle de la taille de la période est de %lu à %lu\n"
+
+#: ../speaker-test/speaker-test.c:364
+#, c-format
+msgid "Requested period time %u us\n"
+msgstr "Temps de période demandé %u µs\n"
+
+#: ../speaker-test/speaker-test.c:367
+#, c-format
+msgid "Unable to set period time %u us for playback: %s\n"
+msgstr "Le temps de période %u µs n'a pas pu être défini pour la lecture: %s\n"
+
+#: ../speaker-test/speaker-test.c:373
+#, c-format
+msgid "Requested buffer time %u us\n"
+msgstr "Temps tampon demandé %u µs\n"
+
+#: ../speaker-test/speaker-test.c:376
+#, c-format
+msgid "Unable to set buffer time %u us for playback: %s\n"
+msgstr "Le temps tampon de %u µs n'a pas pu être définie pour la lecture: %s\n"
+
+#: ../speaker-test/speaker-test.c:385
+#, c-format
+msgid "Using max buffer size %lu\n"
+msgstr "Taille max. de tampon %lu utilisée\n"
+
+#: ../speaker-test/speaker-test.c:388
+#, c-format
+msgid "Unable to set buffer size %lu for playback: %s\n"
+msgstr "La taile de tampon %lu n'a pas pu être définie pour la lecture: %s\n"
+
+#: ../speaker-test/speaker-test.c:394
+#, c-format
+msgid "Periods = %u\n"
+msgstr "Périodes = %u\n"
+
+#: ../speaker-test/speaker-test.c:397
+#, c-format
+msgid "Unable to set nperiods %u for playback: %s\n"
+msgstr "nperiods %u n'a pas pu être défini pour la lecture: %s\n"
+
+#: ../speaker-test/speaker-test.c:406
+#, c-format
+msgid "Unable to set hw params for playback: %s\n"
+msgstr "Les paramètres matériel n'ont pas pu être définis pour la lecture: %s\n"
+
+#: ../speaker-test/speaker-test.c:412
+#, c-format
+msgid "was set period_size = %lu\n"
+msgstr ""
+
+#: ../speaker-test/speaker-test.c:413
+#, c-format
+msgid "was set buffer_size = %lu\n"
+msgstr ""
+
+#: ../speaker-test/speaker-test.c:415
+#, c-format
+msgid "buffer to small, could not use\n"
+msgstr "tampon trop petit, il n'a pas pu être utilisé\n"
+
+#: ../speaker-test/speaker-test.c:428
+#, c-format
+msgid "Unable to determine current swparams for playback: %s\n"
+msgstr "Les paramètres logiciels actuels n'ont pas pu être déterminés pour la lecture: %s\n"
+
+#: ../speaker-test/speaker-test.c:435
+#, c-format
+msgid "Unable to set start threshold mode for playback: %s\n"
+msgstr ""
+
+#: ../speaker-test/speaker-test.c:442
+#, c-format
+msgid "Unable to set avail min for playback: %s\n"
+msgstr ""
+
+#: ../speaker-test/speaker-test.c:449
+#, c-format
+msgid "Unable to set sw params for playback: %s\n"
+msgstr "Les paramètres logiciel n'ont pas pu être définis pour la lecture: %s\n"
+
+#: ../speaker-test/speaker-test.c:464
+#, c-format
+msgid "Can't recovery from underrun, prepare failed: %s\n"
+msgstr ""
+
+#: ../speaker-test/speaker-test.c:475
+#, c-format
+msgid "Can't recovery from suspend, prepare failed: %s\n"
+msgstr ""
+
+#: ../speaker-test/speaker-test.c:539 ../speaker-test/speaker-test.c:954
+#, c-format
+msgid "No enough memory\n"
+msgstr "Pas assez de mémoire\n"
+
+#: ../speaker-test/speaker-test.c:544
+#, c-format
+msgid "Cannot open WAV file %s\n"
+msgstr "Le fichier WAV %s n'a pas pu être ouvert\n"
+
+#: ../speaker-test/speaker-test.c:548 ../speaker-test/speaker-test.c:577
+#, c-format
+msgid "Invalid WAV file %s\n"
+msgstr "Fichier WAV incorrect %s\n"
+
+#: ../speaker-test/speaker-test.c:553
+#, c-format
+msgid "Not a WAV file: %s\n"
+msgstr "Le fichier %s n'est pas au format WAV\n"
+
+#: ../speaker-test/speaker-test.c:557
+#, c-format
+msgid "Unsupported WAV format %d for %s\n"
+msgstr "Format WAV %d non supporté pour %s\n"
+
+#: ../speaker-test/speaker-test.c:562
+#, c-format
+msgid "%s is not a mono stream (%d channels)\n"
+msgstr "%s n'est pas un flux en mono (%d canaux)\n"
+
+#: ../speaker-test/speaker-test.c:567
+#, c-format
+msgid "Sample rate doesn't match (%d) for %s\n"
+msgstr "La fréquence d'échantillonage (%d) ne correspond pas à %s\n"
+
+#: ../speaker-test/speaker-test.c:572
+#, c-format
+msgid "Unsupported sample format bits %d for %s\n"
+msgstr "Le format d'échantillonage %d bits n'est pas supporté pour %s\n"
+
+#: ../speaker-test/speaker-test.c:622
+#, c-format
+msgid "Undefined channel %d\n"
+msgstr "Canal non-défini %d\n"
+
+#: ../speaker-test/speaker-test.c:673
+#, c-format
+msgid "Write error: %d,%s\n"
+msgstr "Erreur en écriture: %d,%s\n"
+
+#: ../speaker-test/speaker-test.c:675
+#, c-format
+msgid "xrun_recovery failed: %d,%s\n"
+msgstr ""
+
+#: ../speaker-test/speaker-test.c:734
+#, c-format
+msgid ""
+"Usage: speaker-test [OPTION]... \n"
+"-h,--help\thelp\n"
+"-D,--device\tplayback device\n"
+"-r,--rate\tstream rate in Hz\n"
+"-c,--channels\tcount of channels in stream\n"
+"-f,--frequency\tsine wave frequency in Hz\n"
+"-F,--format\tsample format\n"
+"-b,--buffer\tring buffer size in us\n"
+"-p,--period\tperiod size in us\n"
+"-P,--nperiods\tnumber of periods\n"
+"-t,--test\tpink=use pink noise, sine=use sine wave, wav=WAV file\n"
+"-l,--nloops\tspecify number of loops to test, 0 = infinite\n"
+"-s,--speaker\tsingle speaker test. Values 1=Left, 2=right, etc\n"
+"-w,--wavfile\tUse the given WAV file as a test sound\n"
+"-W,--wavdir\tSpecify the directory containing WAV files\n"
+"\n"
+msgstr ""
+"Utilisation: speaker-test [OPTION]...\n"
+"-h,--help\taide\n"
+"-D,--device\tpériphérique de lecture\n"
+"-r,--rate\tfréquence du flux en Hz\n"
+"-c,--channels\tnombre de canaux du flux\n"
+"-f,--frequency\tfréquence courbe sinus en Hz\n"
+"-F,--format\tformat d'échantillonage\n"
+"-b,--buffer\ttaille en µs du tampon circulaire\n"
+"-p,--period\ttaille de la période en µs\n"
+"-P,--nperiods\tnombre de périodes\n"
+"-t,--test\tpink=pink noise, sine=courbe sinus, wav=fichier WAV\n"
+"-l,--nloops\tspécifier le nombre de motifs à tester, 0 = infini\n"
+"-s,--speaker\ttest sur une seule enceinte.\n"
+"\t\tValeurs 1=Gauche, 2=Droite, et c.\n"
+"-w,--wavfile\tUtiliser le fichier WAV spécifié pour le test\n"
+"-w,--wavdir\tSpécifier le répertoire contenant les fichiers WAV\n"
+"\n"
+
+#: ../speaker-test/speaker-test.c:852
+#, c-format
+msgid "Invalid number of periods %d\n"
+msgstr "Nombre de périodes %d incorrect\n"
+
+#: ../speaker-test/speaker-test.c:866 ../speaker-test/speaker-test.c:870
+#, c-format
+msgid "Invalid test type %s\n"
+msgstr "Type de test %s incorrect\n"
+
+#: ../speaker-test/speaker-test.c:882
+#, c-format
+msgid "Invalid parameter for -s option.\n"
+msgstr "Paramètre incorrect pour l'option -s.\n"
+
+#: ../speaker-test/speaker-test.c:896
+#, c-format
+msgid "Unknown option '%c'\n"
+msgstr "Option '%c' inconnue\n"
+
+#. fixed format
+#: ../speaker-test/speaker-test.c:910
+#, c-format
+msgid "Playback device is %s\n"
+msgstr "Le périphérique de lecture est %s\n"
+
+#: ../speaker-test/speaker-test.c:911
+#, c-format
+msgid "Stream parameters are %iHz, %s, %i channels\n"
+msgstr "Les paramètres du flux sont %iHz, %s, %i canaux\n"
+
+#: ../speaker-test/speaker-test.c:914
+#, c-format
+msgid "Using 16 octaves of pink noise\n"
+msgstr "Utilisation de 16 octaves de 'pink noise'\n"
+
+#: ../speaker-test/speaker-test.c:917
+#, c-format
+msgid "Sine wave rate is %.4fHz\n"
+msgstr "La fréquence de la courbe sinus est %.4fHz\n"
+
+#: ../speaker-test/speaker-test.c:920
+#, c-format
+msgid "WAV file(s)\n"
+msgstr "fichier(s) WAV\n"
+
+#: ../speaker-test/speaker-test.c:926
+#, c-format
+msgid "Playback open error: %d,%s\n"
+msgstr "Erreur d'ouverture à la lecture: %d,%s\n"
+
+#: ../speaker-test/speaker-test.c:931
+#, c-format
+msgid "Setting of hwparams failed: %s\n"
+msgstr "Échec de la configuration des paramètres matériel: %s\n"
+
+#: ../speaker-test/speaker-test.c:936
+#, c-format
+msgid "Setting of swparams failed: %s\n"
+msgstr "Échec de la configuration des paramètres logiciel: %s\n"
+
+#: ../speaker-test/speaker-test.c:985 ../speaker-test/speaker-test.c:1007
+#, c-format
+msgid "Transfer failed: %s\n"
+msgstr "Échec du transfer: %s\n"
+
+#: ../speaker-test/speaker-test.c:995
+#, c-format
+msgid "Time per period = %lf\n"
+msgstr "Temps par période = %lf\n"
-- 
1.7.6

From 4429363aceb8c11fc69414ad85bce21e6dadb6c2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ozan=20=C3=87a=C4=9Flayan?= <ozan@pardus.org.tr>
Date: Wed, 5 Jan 2011 13:01:04 +0200
Subject: [PATCH] configure.in: Fix xmlto detection

xmlto was never detected when alsaconf is disabled leading to a missing
alsactl_init man page.

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 configure.in |   12 +++++-------
 1 files changed, 5 insertions(+), 7 deletions(-)

diff --git a/configure.in b/configure.in
index 2d6c80c..561ca46 100644
--- a/configure.in
+++ b/configure.in
@@ -102,13 +102,11 @@ AC_ARG_ENABLE(alsaloop,
 AM_CONDITIONAL(ALSALOOP, test x$alsaloop = xtrue)
 
 xmlto=""
-if test x"$alsaconf" = xtrue; then
-   AC_ARG_ENABLE(xmlto,
-     AS_HELP_STRING([--disable-xmlto], [Disable man page creation via xmlto]),
-     xmlto="$enableval", xmlto="yes")
-   if test "$xmlto" = "yes"; then
-      AC_CHECK_PROG([xmlto], [xmlto], [yes])
-   fi
+AC_ARG_ENABLE(xmlto,
+ AS_HELP_STRING([--disable-xmlto], [Disable man page creation via xmlto]),
+ xmlto="$enableval", xmlto="yes")
+if test "$xmlto" = "yes"; then
+  AC_CHECK_PROG([xmlto], [xmlto], [yes])
 fi
 AM_CONDITIONAL(USE_XMLTO, test x"$xmlto" = xyes)
 
-- 
1.7.6

From cd26f244e7f2648a63411741552c658ca67334e9 Mon Sep 17 00:00:00 2001
From: Raymond Yau <superquad.vortex2@gmail.com>
Date: Mon, 28 Feb 2011 15:36:36 +0100
Subject: [PATCH] alsamixer: fix display of active/inactive controls

Signed-off-by: Raymond Yau <superquad.vortex2@gmail.com>
Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
---
 alsamixer/mixer_widget.c |   11 +++++++++++
 1 files changed, 11 insertions(+), 0 deletions(-)

diff --git a/alsamixer/mixer_widget.c b/alsamixer/mixer_widget.c
index fb352d3..caaf777 100644
--- a/alsamixer/mixer_widget.c
+++ b/alsamixer/mixer_widget.c
@@ -59,10 +59,21 @@ enum channel_mask {
 
 static int elem_callback(snd_mixer_elem_t *elem, unsigned int mask)
 {
+	unsigned int i;
+
 	if (mask & (SND_CTL_EVENT_MASK_REMOVE |
 		    SND_CTL_EVENT_MASK_INFO |
 		    SND_CTL_EVENT_MASK_VALUE))
 		controls_changed = TRUE;
+
+	if (mask & SND_CTL_EVENT_MASK_INFO)
+		for (i = 0; i < controls_count; ++i)
+			if (controls[i].elem == elem) {
+				controls[i].flags &= ~IS_ACTIVE;
+				if (snd_mixer_selem_is_active(controls[i].elem))
+					controls[i].flags |= IS_ACTIVE;
+			}
+
 	return 0;
 }
 
-- 
1.7.6

From a7bd33957e099dea109e219a348b131c7186ee1e Mon Sep 17 00:00:00 2001
From: Peter Korsgaard <jacmet@sunsite.dk>
Date: Mon, 14 Mar 2011 09:48:13 +0100
Subject: [PATCH] alsamixer: fix build on uClibc

exp10 is a glibc extension, which isn't supported on uClibc. Luckily,
exp10() is trivial to compute based on exp(), so add a wrapper for
the uClibc case.

Signed-off-by: Peter Korsgaard <jacmet@sunsite.dk>
Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 alsamixer/volume_mapping.c |    5 +++++
 1 files changed, 5 insertions(+), 0 deletions(-)

diff --git a/alsamixer/volume_mapping.c b/alsamixer/volume_mapping.c
index 9cacad8..1c0d7c4 100644
--- a/alsamixer/volume_mapping.c
+++ b/alsamixer/volume_mapping.c
@@ -37,6 +37,11 @@
 #include <stdbool.h>
 #include "volume_mapping.h"
 
+#ifdef __UCLIBC__
+/* 10^x = 10^(log e^x) = (e^x)^log10 = e^(x * log 10) */
+#define exp10(x) (exp((x) * log(10)))
+#endif /* __UCLIBC__ */
+
 #define MAX_LINEAR_DB_SCALE	24
 
 static inline bool use_linear_dB_scale(long dBmin, long dBmax)
-- 
1.7.6

From 70451054e08e51f7eaebf9e7d72324acdac01cdb Mon Sep 17 00:00:00 2001
From: David Henningsson <david.henningsson@canonical.com>
Date: Mon, 4 Apr 2011 11:28:47 +0200
Subject: [PATCH] alsactl init: Mute CD Playback volume by default

The CD analog playback line is seldom used these days, as all
modern players rip the CD and use the DAC on the sound card.
In addition, it causes background hum on some machines.
Therefore keep it muted by default.

BugLink: http://bugs.launchpad.net/bugs/747184
Signed-off-by: David Henningsson <david.henningsson@canonical.com>
Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 alsactl/init/default |   13 +++----------
 1 files changed, 3 insertions(+), 10 deletions(-)

diff --git a/alsactl/init/default b/alsactl/init/default
index 7f8ec4c..b7cb941 100644
--- a/alsactl/init/default
+++ b/alsactl/init/default
@@ -144,17 +144,10 @@ CTL{name}="Music Playback Switch",CTL{do_search}=="1", \
   CTL{values}="on"
 
 CTL{reset}="mixer"
-CTL{name}="CD Playback Volume",PROGRAM!="__ctl_search", GOTO=""
-# if master volume control is present, turn CD volume to max
-ENV{has_pmaster_vol}=="true",CTL{write}=="0dB",GOTO=""
-ENV{has_pmaster_vol}=="true",CTL{write}=="100%",GOTO=""
-# exception - some HDA codecs have shifted dB range
-CTL{dBmin}=="-34.50dB",CTL{dBmax}=="12.00dB",CTL{write}=="0dB",GOTO=""
-CTL{dBmin}=="-30.00dB",CTL{dBmax}=="0dB",CTL{write}=="0dB",GOTO=""
-CTL{write}!="$env{pvolume}",CTL{values}="$env{ppercent}"
-LABEL=""
+CTL{name}="CD Playback Volume",CTL{do_search}=="1", \
+  CTL{values}="0%"
 CTL{name}="CD Playback Switch",CTL{do_search}=="1", \
-  CTL{values}="on"
+  CTL{values}="off"
 
 CTL{reset}="mixer"
 CTL{name}="Mono Playback Volume",CTL{do_search}=="1", \
-- 
1.7.6

From 5ee6a670751db67f9e2b2910d5b3b6fc6fff8dfd Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Thu, 28 Apr 2011 08:13:28 +0200
Subject: [PATCH] Revert "alsactl - Display help for names command"

This reverts commit 6d32e055d73edfe6be90135c500dcb32491cf04d.

From: Alexander Stein <alexander.stein@systec-electronic.com>
Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 alsactl/alsactl.c |    2 --
 1 files changed, 0 insertions(+), 2 deletions(-)

diff --git a/alsactl/alsactl.c b/alsactl/alsactl.c
index c2120bd..1792747 100644
--- a/alsactl/alsactl.c
+++ b/alsactl/alsactl.c
@@ -68,8 +68,6 @@ static void help(void)
 	printf("  restore <card #> load current driver setup for one or each soundcards\n");
 	printf("                   from configuration file\n");
 	printf("  init	  <card #> initialize driver to a default state\n");
-	printf("  names   <card #> dump information about all the known present (sub-)devices\n");
-	printf("                   into configuration file (DEPRECATED)\n");
 }
 
 int main(int argc, char *argv[])
-- 
1.7.6

From d67a965aec800483ba48d6de736cb3851163e678 Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Fri, 3 Jun 2011 12:41:26 +0200
Subject: [PATCH] aplay: Add -i option for interactive mode

The recent addition of pause/resume control via keyboard brought
a problem when aplay/arecord is invoked in background.  For avoiding
regressions, it's safer to use non-interactive mode as default and
enable the new feature via an option.

Tested-by: Stephen Warren <swarren@nvidia.com>
Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 aplay/aplay.1 |    4 ++++
 aplay/aplay.c |   14 +++++++++++++-
 2 files changed, 17 insertions(+), 1 deletions(-)

diff --git a/aplay/aplay.1 b/aplay/aplay.1
index b6caf0b..8ccf556 100644
--- a/aplay/aplay.1
+++ b/aplay/aplay.1
@@ -137,6 +137,10 @@ by typing aplay.
 Record.  This is the default if the program is invoked
 by typing arecord.
 .TP
+\fI\-i, \-\-interactive\fP
+Allow interactive operation via stdin.
+Currently only pause/resume via space or enter key is implemented.
+.TP
 \fI\-\-disable\-resample\fP
 Disable automatic rate resample.
 .TP
diff --git a/aplay/aplay.c b/aplay/aplay.c
index c09f23c..04959b8 100644
--- a/aplay/aplay.c
+++ b/aplay/aplay.c
@@ -103,6 +103,7 @@ static int avail_min = -1;
 static int start_delay = 0;
 static int stop_delay = 0;
 static int monotonic = 0;
+static int interactive = 0;
 static int can_pause = 0;
 static int verbose = 0;
 static int vumeter = VUMETER_NONE;
@@ -200,6 +201,7 @@ _("Usage: %s [OPTION]... [FILE]...\n"
 "-v, --verbose           show PCM structure and setup (accumulative)\n"
 "-V, --vumeter=TYPE      enable VU meter (TYPE: mono or stereo)\n"
 "-I, --separate-channels one file for each channel\n"
+"-i, --interactive       allow interactive operation from stdin\n"
 "    --disable-resample  disable automatic rate resample\n"
 "    --disable-channels  disable automatic channel conversions\n"
 "    --disable-format    disable automatic format conversions\n"
@@ -404,7 +406,7 @@ enum {
 int main(int argc, char *argv[])
 {
 	int option_index;
-	static const char short_options[] = "hnlLD:qt:c:f:r:d:MNF:A:R:T:B:vV:IPC";
+	static const char short_options[] = "hnlLD:qt:c:f:r:d:MNF:A:R:T:B:vV:IPCi";
 	static const struct option long_options[] = {
 		{"help", 0, 0, 'h'},
 		{"version", 0, 0, OPT_VERSION},
@@ -442,6 +444,7 @@ int main(int argc, char *argv[])
 		{"max-file-time", 1, 0, OPT_MAX_FILE_TIME},
 		{"process-id-file", 1, 0, OPT_PROCESS_ID_FILE},
 		{"use-strftime", 0, 0, OPT_USE_STRFTIME},
+		{"interactive", 0, 0, 'i'},
 		{0, 0, 0, 0}
 	};
 	char *pcm_name = "default";
@@ -608,6 +611,9 @@ int main(int argc, char *argv[])
 			if (file_type == FORMAT_DEFAULT)
 				file_type = FORMAT_WAVE;
 			break;
+		case 'i':
+			interactive = 1;
+			break;
 		case OPT_DISABLE_RESAMPLE:
 			open_mode |= SND_PCM_NO_AUTO_RESAMPLE;
 			break;
@@ -1206,6 +1212,8 @@ static void init_stdin(void)
 	struct termios term;
 	long flags;
 
+	if (!interactive)
+		return;
 	tcgetattr(fileno(stdin), &term);
 	term_c_lflag = term.c_lflag;
 	if (fd == fileno(stdin))
@@ -1221,6 +1229,8 @@ static void done_stdin(void)
 {
 	struct termios term;
 
+	if (!interactive)
+		return;
 	if (fd == fileno(stdin) || term_c_lflag == -1)
 		return;
 	tcgetattr(fileno(stdin), &term);
@@ -1258,6 +1268,8 @@ static void check_stdin(void)
 {
 	unsigned char b;
 
+	if (!interactive)
+		return;
 	if (fd != fileno(stdin)) {
 		while (read(fileno(stdin), &b, 1) == 1) {
 			if (b == ' ' || b == '\r') {
-- 
1.7.6

From a3ebe640a74d4a0e8acd15e31dd83c210b3c1be4 Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Fri, 3 Jun 2011 12:44:17 +0200
Subject: [PATCH] aplay: Avoid recursive signal handling

When abort() is issued in snd_pcm_close() path, it may loop recursively
and crash.

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 aplay/aplay.c |    6 ++++++
 1 files changed, 6 insertions(+), 0 deletions(-)

diff --git a/aplay/aplay.c b/aplay/aplay.c
index 04959b8..72852b0 100644
--- a/aplay/aplay.c
+++ b/aplay/aplay.c
@@ -358,6 +358,12 @@ static void prg_exit(int code)
 
 static void signal_handler(int sig)
 {
+	static int in_aborting;
+
+	if (in_aborting)
+		return;
+
+	in_aborting = 1;
 	if (verbose==2)
 		putchar('\n');
 	if (!quiet_mode)
-- 
1.7.6

From 3bea722b3bfdbec2e26218aca66e55b019a24436 Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Fri, 3 Jun 2011 14:28:28 +0200
Subject: [PATCH] alsamixer: Fix 64bit issues

lrint() returns a long int.

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 alsamixer/mixer_display.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/alsamixer/mixer_display.c b/alsamixer/mixer_display.c
index 51a1546..8ba396a 100644
--- a/alsamixer/mixer_display.c
+++ b/alsamixer/mixer_display.c
@@ -486,17 +486,17 @@ static void display_control(unsigned int control_index)
 		if (control->flags & IS_ACTIVE)
 			wattrset(mixer_widget.window, attr_mixer_active);
 		if (!(control->flags & HAS_VOLUME_1)) {
-			sprintf(buf, "%d", lrint(volumes[0] * 100));
+			sprintf(buf, "%d", (int)lrint(volumes[0] * 100));
 			display_string_in_field(values_y, frame_left - 2, buf, 8, ALIGN_CENTER);
 		} else {
 			mvwprintw(mixer_widget.window, values_y, frame_left - 2,
-				  "%3d", lrint(volumes[0] * 100));
+				  "%3d", (int)lrint(volumes[0] * 100));
 			if (control->flags & IS_ACTIVE)
 				wattrset(mixer_widget.window, attr_ctl_frame);
 			waddstr(mixer_widget.window, "<>");
 			if (control->flags & IS_ACTIVE)
 				wattrset(mixer_widget.window, attr_mixer_active);
-			wprintw(mixer_widget.window, "%-3d", lrint(volumes[1] * 100));
+			wprintw(mixer_widget.window, "%-3d", (int)lrint(volumes[1] * 100));
 		}
 	}
 
-- 
1.7.6

From ce2d64b48addd16c2ba25c76b795a9f7b277e642 Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Fri, 3 Jun 2011 14:30:55 +0200
Subject: [PATCH] aplay: Add include files for mkdir()

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 aplay/aplay.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/aplay/aplay.c b/aplay/aplay.c
index 72852b0..7175652 100644
--- a/aplay/aplay.c
+++ b/aplay/aplay.c
@@ -46,6 +46,8 @@
 #include <sys/uio.h>
 #include <sys/time.h>
 #include <sys/signal.h>
+#include <sys/stat.h>
+#include <sys/types.h>
 #include <asm/byteorder.h>
 #include "aconfig.h"
 #include "gettext.h"
-- 
1.7.6

From 36d642f4481b54c035782ec1a71f7c67f64ed3bf Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Fri, 3 Jun 2011 14:35:44 +0200
Subject: [PATCH] aplay: Use standard endian convesions

asm/*.h stuff shouldn't be used directly from the user-space apps.

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 aplay/aplay.c |   10 +++++-----
 1 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/aplay/aplay.c b/aplay/aplay.c
index 7175652..50e01ef 100644
--- a/aplay/aplay.c
+++ b/aplay/aplay.c
@@ -48,7 +48,7 @@
 #include <sys/signal.h>
 #include <sys/stat.h>
 #include <sys/types.h>
-#include <asm/byteorder.h>
+#include <endian.h>
 #include "aconfig.h"
 #include "gettext.h"
 #include "formats.h"
@@ -1508,9 +1508,9 @@ static void compute_max_peak(u_char *data, size_t count)
 		c = 0;
 		while (count-- > 0) {
 			if (format_little_endian)
-				sval = __le16_to_cpu(*valp);
+				sval = le16toh(*valp);
 			else
-				sval = __be16_to_cpu(*valp);
+				sval = be16toh(*valp);
 			sval = abs(sval) ^ mask;
 			if (max_peak[c] < sval)
 				max_peak[c] = sval;
@@ -1553,9 +1553,9 @@ static void compute_max_peak(u_char *data, size_t count)
 		c = 0;
 		while (count-- > 0) {
 			if (format_little_endian)
-				val = __le32_to_cpu(*valp);
+				val = le32toh(*valp);
 			else
-				val = __be32_to_cpu(*valp);
+				val = be32toh(*valp);
 			val = abs(val) ^ mask;
 			if (max_peak[c] < val)
 				max_peak[c] = val;
-- 
1.7.6

From 471191abe59cce84b104fc6f601cbb852a8d07e7 Mon Sep 17 00:00:00 2001
From: Daniel T Chen <crimsun@ubuntu.com>
Date: Sat, 4 Jun 2011 17:44:43 -0400
Subject: [PATCH] speaker-test.1: Clarify man page by giving examples
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

BugLink: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=620513

From the Debian bug report:
"The speaker-test manpage could be improved somewhat by helping a
little bit the user determine how to find out the devices he can test.

Based on http://alsa.opensrc.org/Speaker-test I have make some changes
to the manpage (diff attached) to describe a little bit more how
speaker-test can be used alongside 'aplay'.

Please consider the following patch for
alsa-utils-1.0.23/speaker-test/speaker-test.1"

Signed-off-by: Javier Fernández-Sanguino Peña <jfs@debian.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 speaker-test/speaker-test.1 |   46 ++++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 45 insertions(+), 1 deletions(-)

diff --git a/speaker-test/speaker-test.1 b/speaker-test/speaker-test.1
index f0948a6..6ef0814 100644
--- a/speaker-test/speaker-test.1
+++ b/speaker-test/speaker-test.1
@@ -11,7 +11,7 @@
 .  fi
 .  PP
 ..
-.TH SPEAKER\-TEST 1 "20 September 2004" speaker-test
+.TH SPEAKER\-TEST 1 "April 2nd, 2011" speaker-test
 .SH NAME
 speaker\-test \- command-line speaker test tone generator for ALSA 
 .SH SYNOPSIS
@@ -20,6 +20,41 @@ speaker\-test \- command-line speaker test tone generator for ALSA
 .SH DESCRIPTION
 \fBspeaker\-test\fP generates a tone that can be used to test the speakers of a computer.
 
+\fBspeaker-test\fP by default will test the \fIdefault\fP device. If you
+want to test another sound device you will have first to get a list of
+all of the sound cards in your system and the devices associated with
+those cards. Notice that there might be for example, one device for
+analog sound, one for digital sound and one for HDMI sound.
+To get the list of available cards and devices you can run \fBaplay -L\fR.
+
+.P \fBaplay\fR's output will be similar to this one:
+
+.nf
+$ aplay -L
+null
+    Discard all samples (playback) or generate zero samples (capture)
+default:CARD=ICH5
+    Intel ICH5, Intel ICH5
+    Default Audio Device
+front:CARD=ICH5,DEV=0
+    Intel ICH5, Intel ICH5
+    Front speakers
+surround40:CARD=ICH5,DEV=0
+    Intel ICH5, Intel ICH5
+    4.0 Surround output to Front and Rear speakers
+(...)
+.fi
+
+.P Each of the devices is listed in the beginning of the definition so,
+in the above example, there are four devices listed: null, default, front
+and surround40. So, if you want to test the last device you can 
+run \fBspeaker-test -Dsurround40:ICH5 -c 6\fR. The \fB-c\fR option will
+indicate that the six audio channels in the device have to be tested.
+
+
+
+
+
 .SH OPTIONS
 
 .TP
@@ -119,6 +154,15 @@ To send a nice low 75Hz tone to the Woofer and then exit without touching any ot
   speaker-test -Dplug:surround51 -c6 -s1 -f75
 .EE
 
+To do a 2-speaker test using the spdif (coax or optical) output:
+.EX
+  speaker-test -Dplug:spdif -c2
+.EE
+
+
+.SH SEE ALSO
+.BR aplay(1)
+
 .SH AUTHOR
 The speaker-test program was written by James Courtier-Dutton.
 Pink noise support was added by Nathan Hurst.
-- 
1.7.6

From 8709ffe841e6f33094f7a547ee86591b29a40cf4 Mon Sep 17 00:00:00 2001
From: Lars-Peter Clausen <lars@metafoo.de>
Date: Thu, 16 Jun 2011 14:19:18 +0200
Subject: [PATCH] alsa-utils: amixer: Fix SND_CTL_TLVT_DB_RANGE handling

Current support for handling SND_CTL_TLVT_DB_RANGE in amixer is completely
broken. This patch fixes it.

Reported-by: Daniel Mack <zonque@gmail.com>
Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 amixer/amixer.c |   14 +++++++-------
 1 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/amixer/amixer.c b/amixer/amixer.c
index a177288..9d2855d 100644
--- a/amixer/amixer.c
+++ b/amixer/amixer.c
@@ -517,20 +517,20 @@ static void decode_tlv(unsigned int spaces, unsigned int *tlv, unsigned int tlv_
 #ifdef SND_CTL_TLVT_DB_RANGE
 	case SND_CTL_TLVT_DB_RANGE:
 		printf("dBrange-\n");
-		if ((size / (6 * sizeof(unsigned int))) != 0) {
+		if ((size % (6 * sizeof(unsigned int))) != 0) {
 			while (size > 0) {
 				printf("0x%08x,", tlv[idx++]);
 				size -= sizeof(unsigned int);
 			}
 			break;
 		}
-		idx = 0;
-		while (idx < size) {
+		while (size > 0) {
 			print_spaces(spaces + 2);
-			printf("rangemin=%i,", tlv[0]);
-			printf(",rangemax=%i\n", tlv[1]);
-			decode_tlv(spaces + 4, tlv + 2, 6 * sizeof(unsigned int));
-			idx += 6 * sizeof(unsigned int);
+			printf("rangemin=%i,", tlv[idx++]);
+			printf(",rangemax=%i\n", tlv[idx++]);
+			decode_tlv(spaces + 4, tlv + idx, 4 * sizeof(unsigned int));
+			idx += 4;
+			size -= 6 * sizeof(unsigned int);
 		}
 		break;
 #endif
-- 
1.7.6

From 0131ab6a67e18ae3c30b7b3fabc2fdf1592f075c Mon Sep 17 00:00:00 2001
From: Tim Blechmann <tim@klingt.org>
Date: Wed, 29 Jun 2011 09:44:06 +0200
Subject: [PATCH] aplay: increase channel limit to 256

aplay is limited to 32 channels, which makes it impossible to use it for
testing devices with more channels. here we increase the limit to 256,
which should be sufficient for a virtual device made of 4 64-channel
soundcards.

Signed-off-by: Tim Blechmann <tim@klingt.org>
Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 aplay/aplay.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/aplay/aplay.c b/aplay/aplay.c
index 50e01ef..07e6bc0 100644
--- a/aplay/aplay.c
+++ b/aplay/aplay.c
@@ -526,7 +526,7 @@ int main(int argc, char *argv[])
 			break;
 		case 'c':
 			rhwparams.channels = strtol(optarg, NULL, 0);
-			if (rhwparams.channels < 1 || rhwparams.channels > 32) {
+			if (rhwparams.channels < 1 || rhwparams.channels > 256) {
 				error(_("value %i for channels is invalid"), rhwparams.channels);
 				return 1;
 			}
@@ -1015,7 +1015,7 @@ static int test_au(int fd, void *buffer)
 	if (hwparams.rate < 2000 || hwparams.rate > 256000)
 		return -1;
 	hwparams.channels = BE_INT(ap->channels);
-	if (hwparams.channels < 1 || hwparams.channels > 128)
+	if (hwparams.channels < 1 || hwparams.channels > 256)
 		return -1;
 	if ((size_t)safe_read(fd, buffer + sizeof(AuHeader), BE_INT(ap->hdr_size) - sizeof(AuHeader)) != BE_INT(ap->hdr_size) - sizeof(AuHeader)) {
 		error(_("read error"));
-- 
1.7.6

